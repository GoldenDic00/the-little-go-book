# စာအုပ်နှင့်ပတ်သတ်၍ 

## လိုင်စင်

The Little Go စာအုပ်သည် Attribution-NonCommercial-ShareAlike 4.0  လိုင်စင်အရ မှတ်တမ်းတင်ထားသည်။ ထိုစာအုပ်အတွက် အခကြေးငွေ ပေးစရာမလို။ သင့်အနေဖြင့် ထိုစာအုပ်ကို ပြန်လည်ဖြန့်ဝေ၊ ပြင်ဆင်၊ ပြသခြင်း ပြုနိုင်သည်။ သို့သော ထိုစာအုပ် မူလစာရေးသူ ဖြစ်သည့် Karl Seguin ကိုပြန်လည် ညွန်းဆိုရမည်ဖြစ်ပြီး စီးပွားဖြစ်သုံးစွဲရန် ခွင့်မပြု။ လိုင်စင်အပြည့်အစုံကို အောက်ပါအတိုင်းဖတ်ရှုနိုင်သည်။

<https://creativecommons.org/licenses/by-nc-sa/4.0/>

## နောက်ဆုံး Version

ယခုစာအုပ်၏ နောက်ဆုံး version ကိုအောက်ဖော်ပြပါလင့်တွင် ဖတ်ရှုနိုင်ပါသည်။
<https://github.com/karlseguin/the-little-go-book>

# အစပျိုး


Language အသစ်တစ်ခုသင်တိုင်း ကျွန်တော်အတွက် စိတ်နှစ်ခွဖြစ်ရပါတယ်။ တဖက်မှာ language တွေဟာ ကျွန်တော်တို့ နေ့စဉ်လုပ်နေတာရဲ့ အခြေခံဖြစ်ပြီးတော့ အပြောင်းအလဲ အသေးလေးတစ်ခုပင် ထိရောက်မှု အများကြီးရှိနိုင်ပါတယ်။ တခုခုကို နှိပ်လိုက်ပါက သင့် program ကိုသက်ရောက်စေနိုင်သည့် ရလဒ်ကပင် *ဟာကနဲ* ဖြစ်နိုင်ပြီး သင့်အနေဖြင့် အခြား language များ၏ အမြင်ကိုပြန်၍ ပြောင်းလဲစေနိုင်သည်။ တဖက်ကပြန်ကြည့်ပါက language  များသည် ဆင့်ကဲ့ design လုပ်ထားသည်ဖြစ်၍ ဘာသာစကား အသစ် တစ်ခုကို လေ့လာပါက Keyword အသစ် ၊ type system နှင့် coding style များမှ အစ library အသစ်များ ၊ အဖွဲ့အစည်းအသစ်များနှင့် paradigms အသစ်များကို လေ့လာရခြင်းသည် အင်မတန်ပင် အလုပ်ရှုပ်သည်က မငြင်းသာ။ တခြားအရာများနှင့် နှိုင်းယှဉ်ပါက language အသစ်ကို လေ့လာခြင်းသည် အချိန်ကို အကျိုးရှိစွာ အသုံးချသည်ကော ဟုတ်ပေပါ့မလား ဟု သံသယဝင်မိလေသည်။

သို့ပင်သော်ညား ကျွန်တော်တို့သည် *ရှေ့ကိုဆက်တိုး* ရမည်ဖြစ်သည်။ language များသည် ကျွန်တော်တို့ လုပ်ဆောင်သည့် အရာများ၏ အခြေခံဖြစ်သဖြင့် ကျွန်တော်တို့ အနေဖြင့် *ခြေလှမ်းတစ်လှမ်းချင်း* ဖြစ်စေ လှမ်းရမည် ဖြစ်သည်။ အပြောင်းအလဲများမှာ တဆင့်ချင်းစီဖြစ်သော်လည်း  productivity ၊ Readability ၊ Performance ၊ Testability ၊ Dependency Management ၊  Error Handling ၊ Documentation ၊ Profiling ၊ Communities နှင့် Standard Libraries များမှာ ကျယ်ပြန့်ပြီး ထိရောက်မှုမှာလည်း ကွာခြားလှပေသည်။ *ဓားချက်တစ်ထောင်ဖြင့်* အခုတ်ခံရသည်ကို အကောင်း ဘယ်လိုပြောရမှန်းပင် မသိပေ။

ထိုနေရာတွင် မေးစရာ ပေါ်လာသည်က အဘယ်ကြောင့် *Go* ကိုရွှေးချယ်ခဲ့သနည်း။ ကျွန်တော်အတွက်တော့ ဖြေစရာနှစ်ခုရှိသည်။ ပထမတစ်ခုက ရိုးရိုးရှင်းရှင်း standard libraries များနှင့် ရိုးရိုးရှင်းရှင်း language တစ်ခုကြောင့်ဖြစ်သည်။ ထိုကြောင့် ထပ်ဆင့်တိုးတက်သွားသော Go ၏ သဘာဝကြောင့် ကျွန်တော်တို့ တခြား language များတွင် တွေ့ကြုံနေရသည့် အရှုပ်ထုပ်များကို ရှင်းလင်းစေနိုင်သည်။ နောက်တစ်ခုမှာ တခြား developer များအနေဖြင့် မိမိတို့တည်ရှိပြီးသော အရည်အချင်းများအနက် ပေါင်းစပ်အသုံးချနိုင်သည်။

Go မှာ system language (ဥပမာ operation system များ၊ device driver များ တည်ဆောက်ရန်) အနေဖြင့်ဖွဲ့စည်းထားပြီး C နှင့် C++ developer များအတွက် ရည်ရွယ်ထားသော်လည်းလက်တွေ့တွင် ကျွန်တော်လို application developer များမှာ အဓိက Go ကိုအသုံးပြုသူ အများစုဖြစ်နေသည်။ ဘာဖြစ်လို့ ဆိုသည်ကို system developers မဟုတ်သဖြင့် မယ်မယ်ရရ မပြောနိုင်သော်လည်း ကျွန်တော်တို့လို့ website တည်ဆောက်သူများ ၊ Service နှင့် desktop application တည်ဆောက်သူများအတွက်မူ high-level နှင့် Low-level application များ အကြား ပေါင်းကူတံတားတစ်ခု သဖွယ်ဖြစ်နေသည်။

Messaging ၊ Caching ၊ နှင့် အချက်အလက်အမြောက်အများ အသုံးပြု၍ တွက်ချက်ရသည်များ ၊ Command Line Interface များ ၊ Logging ၊ Monitoring နှင့် မည်သို့မည်ပုံ ခေါင်းစဉ်တပ်ရမှန်းမသိသော အချို့သော အလုပ်များအတွက် အချိန်ကြာလာသည်နှင့်အမျှ ပို၍ရှုပ်ထွေးလာပြီး တပြိုင်နက် အမြောက်အများ ထောင်နှင့်သောင်းနှင့်ချီ၍ တိုင်းတာလာရသည့်အခါ မိမိတို့လိုအပ်သလို Infrastructure ကိုပြုပြင်ပြောင်းလဲနိုင်ရန် လိုအပ်လာသည်။ ထိုသို့သော စနစ်များကို လူအများစု အသုံးပြုသည့် Ruby သို့မဟုတ် Python ကဲ့သို့ Language များ အသုံးပြု၍ရေးသားနိုင်သော်လည်း တင်းကျပ်သော Type စနစ်ကို အသုံးပြုသော Language များအသုံးပြုပါက အကျိုးဖြစ်ထွန်းသလို Performance လည်းပို၍ ကောင်းပေသည်။ ထိုနည်းတူ Go ကိုအသုံးပြု၍ website များ *ရေးသားနိုင်သော်လည်း* ထိုသို့သော စနစ်များကို များသောအားဖြင့် ပို၍ ဖြန့်ကျက်ရလွယ်သည့်  Node သို့မဟုတ် Ruby ကိုပို၍ သဘောကျမိသည်။

Go အားသာသည့် တခြားအပိုင်းများလည်း ရှိသေးပေသည်။ ဥပမာ Compile လုပ်ထားသော Go Program တစ်ခုအတွက် dependency များမလိုခြင်း။ သင့်အနေဖြင့် user များ Ruby သို့မဟုတ် JVM သွင်းထားခြင်း ရှိမရှိ ၊ ရှိလျှင်ပင် မည်သည့် version ကိုသွင်းထားသနည်း စဉ်းစားရန်မလို။ ထိုကြောင့် Go သည် Command line အတွက်နှင့် distribute လုပ်ရန်လိုသည့် utlity program များ (ဥပမာ Log Collector လိုမျိုး) အတွက် တဖြည်းဖြည်း လူကြိုက်များလာသည်။ 

အချုပ်အားဖြင့်ပြောရလျှင် Go ကိုသင်ယူခြင်းသည် သင့်အချိန်ကို အကျိုးရှိစွာ အသုံးချခြင်း ပင်ဖြစ်သည်။ သင့်အနေဖြင့် နာရီပေါင်းများစွာ အချိန်ကုန်ပြီး Go ကိုကျွမ်းကျင်ရန် လုပ်စရာမလိုပဲ သိသလောက်နဲ့ပင် လက်တွေ့အသုံးချနိုင်သည်။

## စာရေးသူမှ အမှာစာ


ဒီစာအုပ်ကို ရေးရန် တွန့်ဆုတ်နေသည့် အကြောင်းအရင်းများစွာ ရှိသည့်အနက် ပထမဆုံးတစ်ခုမှာ Go ၏ Documentation ဖြစ်သော  [Effective Go](https://golang.org/doc/effective_go.html) အတော်ပင် အနှစ်ကျသည်။ 

နောက်တစ်ခုမှာ Language အကြောင်း စာအုပ်ထုတ်ရန် ရေးရသည့် အခါ စိတ်တိုင်းမကျ။ Little MongoDB စာအုပ်ထုတ်တုံးက စာဖတ်သူများသည် Relational Database နှင့် Modeling အကြောင်း အခြေခံကို သိရှိမည်ဟု ယူဆနိုင်ပြီး The Little Redis စာအုပ်တွင်မှု သင့်အနေဖြင့် Key Value Store အကြောင်း ရင်းနှီးမည်ဟု ယူဆနိုင်သည်။

စာပိုဒ်နှင့် အခန်းခွဲများအကြောင်း စဉ်းစားရင်း သဘောပေါက်မိသည်က ယခု ကိစ္စတွင်တော့ ၎င်းကဲ့သို့ မှတ်ယူရန် မဖြစ်နိုင်ပေ။ သင့်အတွက် Interface ဆိုသည်မှာ အဘယ်နည်းကို လေ့လာရန် အချိန်မည်မျှယူမည်နည်း ဆိုသည်က အခြားသောသူများအနေဖြင့် *Go တွင် Interface ရှိသည်* ဟု သိထားရုံဖြင့် လုံလောက်သောသူများနှင့်မတူပေ။ နောက်ဆုံးတွင်တော့ တချို့အပိုင်းများ သိပ်အသေးစိတ်နေသော်လည်းကောင်း ၊ လိုအပ်နေသော်လည်းကောင်း စာဖတ်သူအနေဖြင့် အသိပေးနိုင်မည် ဟုမှတ်ယူရင်း ရေးရပါသည်။ ထိုသည့်ကို ထောက်ရှု၍ စာအုပ်၏ အနေအထားကို သဘောပေါက်နိုင်သည်။


# စတင်ခြင်း

သင့်အနေဖြင့် Go နှင့်ရင်းနှီးလိုပါက ဘာမှ install လုပ်ရန်မလိုပဲ [Go Playground](https://play.golang.org/) တွင်စမ်းသပ်နိုင်သည်။ ထိုအပြင် Go Code မှာကို မျှဝေလေ့လာနိုင်သော [Go's discussion forum](https://groups.google.com/forum/#!forum/golang-nuts) တွင် အကူအညီတောင်းနိုင်ပြီး stackoverflow တွင်လည်း မေးလိုရာမေးနိုင်သည်။ 

Go ကို Install လုပ်ရသည်မှာ ခပ်ရိုးရိုးပင်။ Source မှဖြစ်စေ install လုပ်နိုင်သောလည်း compiled လုပ်ပြီးသား binary ကိုအသုံးပြုရန် အကြုံပေးလိုသည်။ [Go Download Page](https://golang.org/dl/) ကိုသွားပါက Platform မျိုးစုံအတွက် Installer များကိုတွေ့ရမည်ဖြစ်သည်။ ၎င်းတို့ကို ခဏဘေးဖယ်ပြီး Go ကို မည်သို့ setup လုပ်ရန် ကိုယ်ဖာသာကိုယ် လေ့လာကြပါစို့။ သင်တွေ့သည့် အတိုင်း သိပ်မခက်လှပါ။ 

တချို့သော ဥပမာများမှလွဲ၍ Go သည် Workplace တစ်ခုအတွင်း ရေးရန်ရည်ရွယ်ထားသည်။ Workplace ဆိုသည်မှာ `bin`၊ `pkg` နှင့် `src` ဟုသော folder အသေးများပါဝင်သော folder တစ်ခုဖြစ်သည်။ သင့်အနေဖြင့် ကိုယ်တိုင်စိတ်ကြိုက် folder များ မဆောက်သင့်ပါ။ 

ဥပမာ ကျွန်တော်၏ projects များကို `~/code` အတွင်း သိမ်းထားသည် ဆိုပါစို့။ `~/code/blog`  တွင် ကျွန်တော် blog နှင့်ပတ်သတ်သည့် Code များရှိမည်။ Go တွင်မူ ကျွန်တော် Workplace က `~/code/go` ဖြစ်ပါက Go နှင့်ပတ်သတ်သော blog ၏ Code များမှာ `~/code/go/src/blog` တွင်ရှိမည်ဖြစ်သည်။

ထိုကြောင့် `go` folder များတွင် သင့် source code များကို `src` ဟုသော folder အသေးကို အရင်ဦးဆုံးထည့်ရမည်ဖြစ်သည်။ 


## OSX / Linux

ကိုယ့် platform အတွက် ကိုက်ညီသော `tar.gz` ကို download လုပ်ပါ။ OSX အတွက်မူ `go#.#.#.darwin-amd64-osx10.8.tar.gz` ဟုပုံစံဖြင့်ဖြစ်လိမ့်မည်။ နောက်မှ `#.#.#` Go ၏ နောက်ဆုံး version နံပါတ်များဖြစ်မည်။

folder လမ်းကြောင်း `/usr/local` အတွင်းသို့  `tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz`. ဟုရိုက်ထည့်ပြီး ဖြေချလိုက်ပါ။

ထိုနောက် environment variable နှစ်ခု သတ်မှတ်ရန်လိုပါလိမ့်မည်။ 


  ၁. သင့်၏ workplace ကို `GOPATH` ဖြင့်ညွန်းဆိုပါ။ ကျွန်တော်အတွက်တော့ `$HOME/code/go` ဆိုရင်ရပါပြီ။
  ၂. ထိုနောက် Go ၏ binary ကို `PATH` ၏ နောက်ဆုံးတွင် ထည့်ဖြည့်ပေးရန်လိုမည်။ 

ထိုနှစ်ခုကို shell မှ အောက်ပါအတိုင်း ရိုက်ထည့်ပြီး သတ်မှတ်နိုင်ပါသည်။ 

    echo 'export GOPATH=$HOME/code/go' >> $HOME/.profile
    echo 'export PATH=$PATH:/usr/local/go/bin' >> $HOME/.profile

ထိုသို့ သတ်မှတ်ပြီးနောက် shell ကိုပြန်ပိတ်ပြီး ဖွင့်လျှင်ဖွင့် သို့မဟုတ် `source $HOME/.profile` ဟုရိုက်ထည့်ပြီး run နိုင်သည်။

`go version` ဟုရိုက်ထည့်ပြီး မိမိတို့ အသုံးပြုနေသော version ကို `go version go1.3.3 darwin/amd64`  နမူနာပုံစံအတိုင်းတွေ့ရှိနိုင်သည်။


## Windows

နောက်ဆုံး zip file ကိုဒေါင်းပါ။ x64 system တွင်ဖြစ်ပါက  `go#.#.#.windows-amd64.zip` ပုံစံဖြင့် file ကိုဒေါင်းပါ။ `#.#.#` သည်နောက်ဆုံး version ကိုညွန်ပြနေပါမည်။ 

ထိုနောက် သင့်စိတ်ကြိုက်နေရာတစ်ခုတွင် ဥပမာ `c:\Go` လိုမျိုးနေရာတွင် unzip လိုက်ပါ။ 

ထိုနောက် environment variable နှစ်ခု သတ်မှတ်ရန်လိုပါလိမ့်မည်။ 

  ၁. သင့်၏ workplace ကို `GOPATH` ဖြင့်ညွန်းဆိုပါ။ ဥပမာ `c:\users\goku\work\go`
  ၂. သင့်၏ unzip လုပ်ထားသောနေရာရှိ binary ကို `PATH` environment variable တွင်ညွန်းဆိုဖို့လိုမည်။ ဥပမာ `c:\Go\bin`


Control Panel ထဲရှိ `System` ထဲရှိ `Advanced` Tab ကိုနှိပ်ပါက `Environment Variables` ဟု button ကိုတွေ့ရှိရမည်ဖြစ်ပြီး ထိုမှတဆင့် Environment variables များကိုသတ်မှတ်နိုင်သည်။ Windows တစ်ချို့ version များတွင်မူ Control Panel ထဲရှိ `System` မှ `Advanced System Settings` ဟုသော option အတွင်းတွင်ရှိမည်။  

ထိုနောက် command prompt ကိုဖွင့်၍ `go version` ဟုနှိပ်ပါ။ `go version go1.3.3 windows/amd64` ဟုပုံစံဖြင့် output ကိုမြင်ရပေမည်။


# အခန်း (၁) - အခြေခံ


Go သည် C နှင့်ဆင်သော Syntax များနှင့် garbarge collection ပါရှိပြီး compile ပြုလုပ်ရသော type အသားပေး language တစ်ခုဖြစ်သည်။ ဆိုလိုသည်မှာ?


## Compilation


Compilation ဆိုသည်မှာ မိမိတို့ရေးသားထားသော source code ကို low level language (ဥပမာ Go တွင် Assembly သို့ပြောင်းလဲပေးပြီး Java နှင့် C# တို့ အခြား language များသို့လည်းကောင်း) သို့ ပြန်၍ပြောင်းလဲသော ဖြစ်စဉ်ကို ဆိုလိုသည်။ 

ပုံမှန်အားဖြင့် Compile လုပ်ရသော language များသည် Compile လုပ်သည့် အချိန် ကြာလေ့ကြာထရှိသဖြင့် အလုပ်လုပ်ရသည် မှာ သာယာချမ်းမြေ့ခြင်းမရှိလှ ၊ Compile လုပ်ပါက မိနစ်ပိုင်းမှ စ၍ နာရီပိုင်း အထိကြာလျှင် တဆင့်ပြီးတဆင့် ရေးသားရန် ခက်ခဲလှပေသည်။ ထို့ကြောင့် Golang ၏ ရည်ရွယ် တည်ဆောက်ပုံ ကိုယ်တိုင်က Compilation ကြာချိန်ကို လျှော့ချနိုင်ရန် အသားပေးထားသည်။ ထိုအချက်သည် Project အကြီးများနှင့် အလုပ်လုပ်ရသော သူများ ၊ Feedback cycle မြန်ဆန်သဖြင့် Interpreted Language များဖြင့် အလုပ်လုပ်ရသူများ အတွက်ပါ အဆင်ပြေပါသည်။ 

Compiled Language များသည် ပုံမှန်အားဖြင့် ပို၍လျင်မြန်ပြီး ၊ Dependencies များမလိုအပ်ပဲ run နိုင်လေ့ရှိသည်။ (အနည်းဆုံး ထိုအချက်သည် C,C++ နှင့် Go ကဲ့သို့သော Assembly သို့ တိုက်ရိုက် Compile လုပ်နိုင်သည့် language များအတွက်မှန်ကန်သည် ဟု ဆိုရမည်။


## Static Typing

Static Type ဖြစ်သည့်အတွက် variable တိုင်းသည် type တစ်ခုခု (int, string, bool, []byte စသဖြင့်) တစ်ခုခုပေါ်တွင် ကျရောက်နေမည် ဖြစ်သည်။ သို့သော် Variable တစ်ခုကို type သတ်မှတ်သည်ဖြစ်စေ မဟုတ်ပါက compiler အနေဖြင့် type ကို infer လုပ်သွားမည်ဖြစ်သည်။ (ဥပမာ အနေဖြင့် အောက်တွင် ဖော်ပြသွားပါမည်) ။ 

Static typing နှင့်ပတ်သတ်၍ အများအပြား ပြောနိုင်သော်လည်း code ကြည့်ပါက ပို၍ သဘောပေါက်မည် ဖြစ်သည်။ အကယ်၍ သင်သည် Dynamic type language ကိုအသုံးပြုသော နောက်ခံမှ လာပါက အနည်းငယ် အာရုံနောက်မည် ဖြစ်သည်။ သင်တွေးသည်က မမှား သို့သော် အချို့သော အားသာချက်များ အထူးသဖြင့် compile လုပ်ချိန်တွင် တွဲထားသော type များက အားသာချက်ရှိသည်။ ထိုနှစ်ချက်မှာ တွဲလျှက်ရှိပြီး တစ်ခုရှိပါက နောက်တစ်ခု ရှိလေ့ရှိသည်။ သို့သော် golang တွင် အတင်းအကျပ် type သတ်မှတ်ရမည်ဟု စည်းကမ်းဟုမရှိပေ။ ခိုင်မာသော စနစ်တစ်ခုတွင် compiler တစ်ခုအနေဖြင့် စာလုံးပေါင်းမှားသည့် ပြဿနာများကို ကျော်လွန်၍ သိရှိနိုင်စွမ်းရှိမှသာ ပို၍ကောင်းမွန်သော optimization ကိုဆောင်ရွက်နိုင်မည် ဖြစ်သည်။ 

## C-Like Syntax

C,C++, Java, Javascript နှင့် C# ကဲ့သို့သော C နှင့် ဆင်သည့် language များကိုအကျွမ်းဝင်ပါက Go ကို C နှင့်ဆင်သည်ကို သတိထားမိမည်ဖြစ်ပြီး လေ့လာရာတွင်လည်း ပို၍ရင်းနှိးပါလိမ့်မည်။ အကြမ်းအားဖြင့်ပေါ့။ ဥပမာ  `&&` က boolena AND ကဲ့သို့ အသုံးပြုပြီး နှစ်ခုကို နှိုင်းယှဉ်ရန် `==` ကိုအသုံးပြုပြီး လက်သည်းကွင်းဖြစ်သည့် `{` နှင့် `}` ကို scope တစ်ခု၏ အစနှင့်အဆုံးကို ပိုင်းခြားရာတွင် အသုံးပြီး Array သည် 0 မှစသည်။


C နှင့်တူသော syntax ဖြစ်သော်လည်း အခြေအနေများ ဖော်ဲပြသည့် လက်သည်းကွင်း `(` နှင့် `)` တို့နှင့် statement တစ်ခုပြီးတိုင်း semi-colon များမှာ Go တွင် ထည့်သည်ဖြစ်စေ မထည့်သည် ဖြစ်စေ အလုပ်လုပ်သည်။ ဥပမာ
`if` statment တစ်ခုသည် အောက်ပါအတိုင်းဖြစ်မည် ဖြစ်သည်။

```go
if name == "Leto" {
  print("the spice must flow")
}
```

ပို၍ ရှုပ်ထွေးလာသော အခြေအနေများတွင်မူ ပိုင်းခြားရန် လက်သည်းကွင်းများသည် အရေးပါဆဲဖြစ်သည်။ 

```go
if (name == "Goku" && power > 9000) || (name == "gohan" && power < 4000)  {
  print("super Saiyan")
}
```
၎င်းတို့မှ အပ Go သည် C# နှင့် Java တို့ဖြင့်နှိုင်းစာလျှင် C နျင့်ပို့၍ နီးစပ်သည်မှာ syntax တွင်မက ရည်ရွယ်ချက်က အစပင်။ လေ့လာရင်းဖြင့် language ၏ ခပ်ပြတ်ပြတ်နှင့် ရိုးရှင်းမှု တဖြည်းဖြည်း ထင်ဟပ်လာသည်က ပို၍ သိသာလာပေမည်။ 


## Garbage Collected


တချို့ variable များ စတင်တည်ဆောက်ကတည်းက လွယ်ကူသည်။ ဥပမာ function ပြီးဆုံးသွားပါက ပျောက်ကွယ်သွားသော အတွင်းရှိ local variable တစ်ခုကဲ့သို့။ သို့သော တခြားသော ကိစ္စများတွင်မူ အထူးသဖြင့် Compiler အတွက် မရိုးရှင်းပေ။ function တစ်ခုမှ ပြန်လာသော variable တစ်ခု၏ သက်တမ်းသည် တခြားသော variable များနင့် object များ၏ reference လုပ်ထားပုံပေါ်မူတည်၍ ရှုပ်ထွေးလှသည်။ Garabage Collection မရှိပါက developer မှ မည်သည့် variable သည်မည်သည့်နေရာက သုံးထားသည်ကို သိရန်လိုပြီး memory ကို free လုပ်ရန်က ၎င်းတာဝန်ဖြစ်သည်။ C ကဲ့သို့ language တွင်မူ variable ကို `free(str);` ဟု free လုပ်ပေးရန်လိုသည်။

Ruby ၊ Python ၊ Java ၊ Javascript ၊ C# နှင့် GO သိုံသော language များတွင် ၎င်း variable ၏ အခြေအနေများကို စောင့်ကြည့်ပြီး အသုံးမပြုပါက ဖျက်ပစ်သော Garbage Collector များပါရှိပါသည်။ ၎င်းအလုပ်ကိုလုပ်ရသဖြင့် အလုပ်ပိုသော်လည်း ဆိုးရွားလှသည့် bugs များဖြစ်နိုင်ချေကို ရှင်းလင်းနိုင်သည်။ 

## Go Code များ runခြင်း

ကျွန်တော်တို့ ခရီးစဉ်ကို ရိုးရှင်းသည် program တစ်ခုစတင်ရေးသားကာ compile လုပ်ရင်း run ကြည့်ခြင်းဖြင့် စတင်လိုက်ရအောင်။ သင့်ကြိုက်သည့် editor ကိုဖွင့်ပြီး အောက်ပါအတိုင်းရေးသားလိုက်ပါ။

```go
package main

func main() {
  println("it's over 9000!")
}
```

`main.go` ဟု save လိုက်ပါ။ လက်တလောတွင်တော့ သင့်အနေဖြင့် save ချင်သည့်နေရာတွင် save နိုင်သည်။ Go workplace အတွင်းဖြစ်ရန်မလိုပေ။ ထိုနောက် shell/command prompt ကိုဖွင့်၍ save ထားသည့် နေရာကိုသွားလိုက်ပါ။ ကျွန်တော်အတွက်ကတော့ `cd ~/code` ဟုရိုက်ရုံဖြင့် ရောက်သွားသည်။

နောက်ဆုံးတွင် အောက်က အတိုင်း ရိုက်ထည့်ပြီး program ကို run နိုင်သည်။

```
go run main.go
```

အားလုံးအဆင်ပြေပါက  *it's over 9000!* ဟုစာကိုတွေ့ရမည်ဖြစ်သည်။

ဒါဖြင့်နေပါဦး compile လုပ်တာ ဘယ်ရောက်သွားသလဲ? `go run` ဆိုသည်က compile လုပ်ပြီး run ပေးသော command ဖြစ်သည်။ ၎င်းသည် ယာယီ directory ကိုအသုံးပြု၍ program ကို build လုပ်ပြီး execute လုပ်ပြီးနောက် ခြေရာလက်ရာများပါ ဖျောက်သွားခြင်းဖြစ်သည် ယာယီ file ၏နေရာကို အောက်ပါအတိုင်း ရိုက်ထည့်၍ တွေ့ရှိနိုင်သည်။

```
go run --work main.go
```

Compile သက်သက်ပြုလုပ်လိုပါက `go build` ကိုအသုံးပြုနိုင်သည်။

```
go build main.go
```

ထိုသို့ဖြင့် run နိုင်မည့် `main` ဟု executable တစ်ခုထုတ်ပေးမည်ဖြစ်သည်။ Linux နှင့် OSX စနစ်များတွင်မူ ရှေ့မှ dot-slash ခံပြီးမှ ခေါ်ရန် မမေ့သင့်ပေ။ ထိုကြောင့် `./main` ဟု ခေါ်ရမည်ဖြစ်သည်။

Develop လုပ်နေစဉ်တွင် `go run` သို့မဟုတ် `go build` ကိုကြိုက်နှစ်သက်ရာ အသုံးပြုနိုင်ပြီး မိမိတို့ရေးသားပြီးသော code ကို deploy လုပ်လို့ပါက `go build` ဟု binary ထုတ်ပြီး execute ပြုလုပ်နိုင်သည်။

### Main



အပေါ်မှာ ရေးထားသော Code ကိုနားလည်မည် ဟုထင်ပါသည်။ function တစ်ခုတည်ဆောက်ပြီး `println` ဟုသော မူလပထမ ပါလာသည် function ကိုအသုံးချ၍ ရေးသားဖော်ပြလိုက်ခြင်းဖြစ်သည်။ Go ထို function ကိုအလိုအလျောက်သိသည်ဟု သင်ထင်ပါသလား? မဟုတ်ပါ တကယ်တော့ Go အတွက် program တစ်ခုတိုင်း၏ စစချင်း run ရန် entry point မှာ `main` package အတွင်းရှိ `main` function ဖြစ်သည်။

Package များအကြောင်းနှင့်ပတ်သတ်၍ နောက်ပိုင်း အခန်းများတွင် အသေးစိတ် ထပ်၍ပြောသွားမည် ဖြစ်ပြီး ယခုတွင်မူ `main` package အတွင်းတွင်ရေးသားသည့် အခြေခံကိုနားလည်ရန် အဓိကထားရှင်းပြသွားမည်ဖြစ်သည်။ 

သင့်အနေဖြင့် စိတ်ကြိုက် code နှင့် package name ကိုပြောင်းလဲပြီး `go run` ဟု run လိုက်ပါက error တက်မည်ဖြစ်သည်။ ထိုနောက် `main` ဟုပြန်ပြောင်းပြီး တခြား function အမည်ကို အသုံးပြုပါကလည်း တခြား error တက်ဦးမည် ဖြစ်သည်။ အပေါ်ကဲ့သို့ပြောင်းလဲပြီး `go build` ဟုရိုက်ထည့်လိုက်ပါ။ ထိုအချိန်တွင် compile လုပ်မည်ဖြစ်သော်လည်း entry point မရှိသဖြင့် ဘာမှ run မည်မဟုတ်ပေ။ library တစ်ခုကိုတည်ဆောက်ပါက ထိုကဲ့သို့ အခြေအနေမျိုးသည် ပုံမှန်ပင်ဖြစ်သည်။


## Imports

Go တွင် `println` ကဲ့သို့သော built-in functions များစွာပါရှိပြီး အသုံးပြုနိုင်ရန် reference လုပ်စရာမလိုပေ။ သို့သာ Go ၏ standard libtary ကိုသာအသုံးပြုပြီး thirdparty library များကိုရှောင်ရှားပါက ခပ်ဝေးဝေးရောက်နိုင်မည် မဟုတ်ပေ။ ထိုအတွက် Go တွင် အပြင်မှ Package များမှ Code များကို အသုံးပြုလိုပါက `import` keyword ကိုအသုံးပြုနိုင်သည်။

ကျွန်တော်တို့ program ကိုအောက်ပါအတိုင်း ပြောင်းလဲကြည့်လိုက်ပါ။

```go
package main

import (
  "fmt"
  "os"
)

func main() {
  if len(os.Args) != 2 {
    os.Exit(1)
  }
  fmt.Println("It's over", os.Args[1])
}
```

အောက်ကအတိုင်း run နိုင်ပါသည်။

```
go run main.go 9000
```

ယခု ကျွန်တော်တို့ အသုံးပြုနေသည်မှာ Go ၏ standard package များဖြစ်သော် `fmt` နှင့် `os` တို့ဖြစ်သည်။ ထိုအပြင် မူလပါရှိပြီး ဖြစ်သော `len` ဟုသော function ကိုပါ မိတ်ဆက်ပေးလိုက်သည်။ `len` သည် string တစ်ခု၏ size ကိုသော်လည်းကောင်း dictionary ဖြစ်ပါက ပါဝင်သော value အရေအတွက်ကို လည်း ယခုကဲ့သို့သော array ဖြစ်ပါက ပါဝင်သော element အရေအတွက်ကို ဖော်ပြပေးသည်။ အဘယ်ကြောင့် သင့်အနေဖြင့် argument (၂)ခုကို မျှော်လင့်ထားသနည်းဟု ဆိုပါက index 0 တွင်ရှိသည့် ပထမ argument သည် လက်ရှိ run နေသော executable ၏ path အနေဖြင့် ပါရှိမည်ဖြစ်သည်။ (program ကို print ထုတ်မည့် value ပြောင်းလဲခြင်းဖြင့် ကိုယ်တိုင် စမ်းသပ်နိုင်သည်။)

package ၏ အမည်များကို function အမည်များ၏ ရှေ့တွင် prefix အနေဖြင့် သုံးနေခြင်း (ဥပမာ `fmt.Println` ) ကို သတိထားမိမည် ဖြစ်သည်။ ၎င်းသည် တခြား language များနှင့် အဓိက ကွာခြားချက်ဖြစ်ကာ အသေးစိတ်ကို နောက်ပိုင်း အခန်းများတွင် ရှင်းပြသွားပါမည်။ အခုတွင်မူ package တစ်ခုကို import လုပ်တက်ပြီး အသုံးပြုတက်ပါက အစကောင်းဟု ဆိုရမည်။ 

Package များ import လုပ်ရာတွင် Go သည် အလွန်တင်းကျပ်ပါသည်။ package တစ်ခုကို import ပြီး အသုံးမပြုပါက compile လုပ်နိုင်မည် မဟုတ်။ အောက်က အတိုင်း run ကြည့်ပါ။


```go
package main

import (
  "fmt"
  "os"
)

func main() {
}
```


`fmt` နှင့် `os` နှစ်ခုကို import လုပ်ထားပြီး အသုံးမပြုသောကြောင့် error နှစ်ခုတက်လိမ့်မည်ဖြစ်သည်။ အာရုံမနောက်ချေဘူးလား။ မှန်ပါသည်။ သို့သော် အချိန်ကြာလာသည်နင့်အမျှ အာရုံနောက်သောလည်း ရေးသာကျလာမည် ဖြစ်သည်။ တော်တော်များများ ကိုယ်တိုင်ကိုယ်ကျ ကြုံချင်မှကြုံရသောလည်း အသုံးမပြုသော import များသည် program ကိုနှေးစေသောကြောင့် Go တွင် တင်းကျပ်ထားခြင်းဖြစ်သည်။ 

မှတ်သားရန် နောက်တစ်ခုမှာ Go ၏ standard library သည်ရှာဖွေရန် အချက်အလက်စုံလင်လှသည်။ <https://golang.org/pkg/fmt/#Println> ကိုသွား၍ ကျွန်တော်တို့ အသုံးပြုသည့် `Println` အကြောင်းကိုသာမက ၎င်းကို click နှိပ်၍ မည်သို့မည်ပုံရေးသားထားသည်ကိုပါ ဖတ်ရှုနိုင်သည်။ ထိုနောက် အပေါ်ဘက်သို့ scroll ပြုလုပ်၍ Go ၏ format လုပ်နိုင်စွမ်းကိုပါ လေ့လာနိုင်မည်ဖြစ်သည်။ 

အင်တာနက်မရပါက Documentation ကို offline အနေဖြင့် အောက်ပါအတိုင်း run နိုင်မည်ဖြစ်သည်။

```
godoc -http=:6060
```

ထိုနောက် browser ပေါ်တွင် `http://localhost:6060` ဟု url ကိုခေါ်ကြည့်ပါ။

## Variables နှင့်ကြေညာခြင်းများ

ဒီစာအုပ်မှာ *ဒီလိုမျိုး x=4 ဟု variable ကြေညာပြီး assign လုပ်လိုက်* ဟုများသာလွယ်လျှင် အလွန်ကောင်းမည်။ သို့သော် Go တွင်ထိုကိစ္စမှာ အနည်းငယ်ရှုပ်ထွေးသည်ဟု ဆိုရမည်။ မည်သို့မည်ပုံဆိုသည်ကို အောက်မှ ဥပမာများကို ဖတ်ရှုပြီးသိနိုင်ပါသည်။ နောက်အခန်းတွင်မူ Structure များတည်ဆောက်အသုံးပြုမှု အပိုင်းကိုပါ ရေးသားသွားမည်ဖြစ်သည်။ သို့ပင်သော်ညား မိမိနှင့်ရင်းနှီးသွားရန် အချိန်တစ်ခုလိုအပ်ပါလိမ့်မည်။

သင့်အနေဖြင့် *ဘာလို့ ဒီလောက်တောင် ရှုပ်ထွေးတာလဲ* ဟုထင်ကောင်းထင်လိမ့်မည်။ ယခုတော့ ဥပမာ အနေဖြင့်ကြည့်ကြည့်ပါ။ Go တွင် အရိုးရှင်းဆုံး variable ကြေညာခြင်းနှင့်သတ်မှတ်ခြင်းသည် အောက်ပါအတိုင်းဖြစ်သည်။ 


```go
package main

import (
  "fmt"
)

func main() {
  var power int
  power = 9000
  fmt.Printf("It's over %d\n", power)
}
```


၎င်းတွင် `power` ဟုသော variable ကို `int` အမျိုးအစားအဖြစ်သတ်မှတ်လိုက်သည်။ မူလအတိုင်းဆိုပါက go တွင် variable များကို နိတ္ထ တန်ဖိုးများ သတ်မှတ်လေ့ရှိသည်။ Integer ဆိုပါက `0` ၊ boolean ဆိုပါက `false` ၊ strings ဆိုပါက `""` စသဖြင့်စသဖြင့်။ ထိုကြောင့် နောက်တစ်ကြောင်းတွင် `power` ဟုသော variable တွင် တန်ဖိုး `9000` ကိုသတ်မှတ်လိုက်ခြင်းဖြစ်သည်။ ထိုနှစ်ကြောင်းကို တစ်ကြောင်းထဲ အဖြစ် အောက်ပါ အတိုင်းရေးသားနိုင်သည်။ 

```go
var power int = 9000
```

သို့ပင်သော်ညား စာအများကြီးရိုက်နေရသေးသည်။ Go အပေါ်ကဲ့သို့သော ကြေညာသတ်မှတ်ချက်အတွက် type ကို infer ပြုလုပ်ပေးသော အတိုကောက် `:=`operator ရှိပါသည်။


```go
power := 9000
```

အတော်ပင် အသုံးဝင်ပြီး function များဖြင့်လည်း အသုံးပြုနိုင်သည်။

```go
func main() {
  power := getPower()
}

func getPower() int {
  return 9001
}
```

သတိပြုရမည်မှာ `:=` သည် assign ပြုလုပ်ရုံသာမက declare ပြုလုပ်ရာတွင်လည်းပါဝင်သည်။ ထိုကြောင့် variable တစ်ခုကို နှစ်ခါမကြေညာနိုင်သဖြင့် အောက်ပါအတိုင်း ရေးပါက error တက်မည်ဖြစ်သည်။


```go
func main() {
  power := 9000
  fmt.Printf("It's over %d\n", power)

  // COMPILER ERROR:
  // no new variables on left side of :=
  power := 9001
  fmt.Printf("It's also over %d\n", power)
}
```

*no new variables on left side of :=* ဟု compiler ကအချက်ပေးမည်ဖြစ်သည်။ ဆိုလိုသည်မှာ ပထမတခါ variable ကြေညာပါက `:=` ကိုသုံးနိုင်ပြီး ဒုတိယတစ်ခေါက်တွင်မူ `=` ကိုသာသုံးရမည်ဖြစ်သည်။ မှန်သည်ကမှန်သော်လည်း အကျင့်ပါနေသဖြင့် မည်သည်ကို သုံးရမည် စဉ်းစားရသည်မှာ နည်းနည်းတော့ တိုင်ပတ်သည်။

အပေါ်က error ကိုသေချာဖတ်ကြည့်ပါက *variables*  ဟုသော အများကိန်းကို ညွန်းဆိုထားသည်ကိုတွေ့ရမည်။ အဘယ်ကြောင့်ဆိုသော go တွင် variable များစွာကို `=` နှင့် `:=` ကိုအသုံးပြုနိုင်သည်။


```go
func main() {
  name, power := "Goku", 9000
  fmt.Printf("%s's power is over %d\n", name, power)
}
```

variable များအနက် တစ်ခုက အသစ်ဖြစ်ပါက `:=` ကိုအသုံးပြုနိုင်သည်။ ဥပမာ


```go
func main() {
  power := 1000
  fmt.Printf("default power is %d\n", power)

  name, power := "Goku", 9000
  fmt.Printf("%s's power is over %d\n", name, power)
}
```

`power` သည်နှစ်ခါသုံးထားသော်လည်း ဒုတိယတစ်ခါတွက် compiler မှ error မတက်ချေ။ အဘယ်ကြောင့်ဆိုသော `name` variable မှာမူ အသစ်ဖြစ်သောကြောင့် ခွင့်လွတ်ထားခြင်းဖြစ်သည်။ သို့သော် `power` ၏ type ကိုမူ ပြောင်းလဲခွင့်မပေးပေ။ integer ဟုကြေညာထားသောကြောင့် integer တန်ဖိုးသာ သတ်မှတ်ခွင့်ပေးမည်ဖြစ်သည်။

လောလောဆယ် နောက်ဆုံးတစ်ခုအနေဖြင့် သိထားသင့်သည်က import ကဲ့သို့ပင် Go အတွင် အသုံးမပြုသော variable များကိုကြေညာခွင့်မပေးချေ။ ဥပမာ

```go
func main() {
  name, power := "Goku", 1000
  fmt.Printf("default power is %d\n", power)
}
```

တွင် `name` variable သည် ကြေညာထားပြီး အသုံးမပြုသောကြောင့် compile ပြုလုပ်မည်မဟုတ်။ import ကဲ့သို့ပင်အာရုံနောက်သောလည်း Code ၏ cleaniess နှင့် readability ကိုအထောက်အကူပြုပါသည်။

ကြေညာခြင်းနှင့် သတ်မှတ်ခြင်းအတွက် သင်ယူရန် ကျန်ရှိသေးသော်လည်း ယခုတွင် သင်မှတ်ထားရန်လိုသည်မှာ နတ္တိတန်ဖိုး အတွက် `var NAME TYPE` ဟု အသုံးပြုနိုင်ပြီး `NAME := VALUE` မှာ နှစ်ခုလုံးကို တပေါင်းတည်းပြုလုပ်ကာ ကြေညာပြီးသော variable များအတွက်သာ `NAME = VALUE` ဟုသုံးနိုင်သည်။


## Function ကြေညာခြင်းများ

Go တွင် function များသည် တခုထက်ပိုသော variable များကို return ပြန်နိုင်သည်။ အောက်က ဥပမာထဲရှိ function များဖြစ်သည့် return မပါသော ၊ return value တစ်ခုဖြင့် ၊ return value နှစ်ခုဖြင့် function ၃ခုကိုကြည့်ကြည့်ပါ။


```go
func log(message string) {
}

func add(a int, b int) int {
}

func power(name string) (int, bool) {
}
```

နောက်ဆုံးတစ်ခုကို အောက်ပါအတိုင်းခေါ်နိုင်သည်။

```go
value, exists := power("goku")
if exists == false {
  // handle this error case
}
```

တခါတရံ သင့်အနေဖြင့် return value တစ်ခုကိုသာ လိုချင်သည့်အနေအထားမျိုးရှိပါက မလိုအပ်သော တစ်ခုကို `_` ဟု assign ပြုလုပ်နိုင်သည်။


```go
_, exists := power("goku")
if exists == false {
  // handle this error case
}
```

`_` သည် ဗလာ identifier ဖြစ်ပြီး return value မယူရန် အထူးတည်ဆောက်ထားသဖြင့် ကြိမ်ဖန်များစွာ `_` ကိုအသုံးပြုနိုင်သည်။

နောက်ဆုံးတွင် function ကြေညာခြင်းနှင့်ပတ်သတ်၍ အောက်ပါအတိုင်းပုံစံမျိုးမြင်တွေ့နိုင်သည်။ ပါဝင်သော parameter များသည် အမျိုးအစားတူညီပါက အတိုကောက် ပုံစံဖြင့် အသုံးပြုနိုင်သည်။

```go
func add(a, b int) int {

}
```

value များစွာပြန်ခြင်းနှင့် `_` ကိုအသုံးပြုရခြင်းသည် Go တွင်မကြာခဏကြုံတွေ့ရမည့် အရာများဖြစ်သည်။ return value များကို အမည်ပေးခြင်း နှင့် အနည်းငယ်လျော့ရဲသော parameter declaration များကိုမူ သိပ်ကြုံရမည် မဟုတ်။ သို့သော် အနှေးနှင့်အမြန်ကြုံရမည်ဖြစ်၍ သိထားရန်လိုသည်။

## နောက်အခန်း မဖတ်ခင်

အခု ကြုံရသော အချက်များသည် သေးငယ်ပြီး အဆက်အစပ်မရှိဖြစ်ကောင်း ဖြစ်သော်လည်း တဖြည်းဖြည်းနှင့်ပို၍ ကြီးမားသော ဥပမာ များကို တည်ဆောက်၍ တစ်ခုနှင့်တစ်ခု ဆက်စပ်မိမည်ဟု မျှော်လင့်မိပါသည်။

dynamic language ရေးသားသော နောက်ခံမှလာခဲ့ပါက type များအကြားရှုပ်ထွေးမှုနှင့် ကြေညာခြင်းများသည် အနည်းငယ် အဟန့်အတားဖြစ်မည်ကို မငြင်းလို။ တချို့ system များအတွက် dynamic language များသည် အလုပ်ပိုဖြစ်လေ့ရှိသည်။

Static Type Language နောက်ခံမှ လာခဲ့သည် ဖြစ်သော သင့်အနေဖြင့် Go ကိုအသုံးပြုရသည်မှာ အဆင်ပြေပါလိမ့်မည်။ 
Go တစ်ခုတည်းတွင် ပါသည် မဟုတ်သော်လည်း type infer လုပ်၍ရခြင်းနှင့် return value အများပေးလို့ရချင်သည် မိုက်သည် ဟုဆိုရမည်။ သင်ယူနေရင်း သေသပ်လှပ သည့် syntax ပုံစကို ပို၍သဘောကျလာမိ ဟု မျှော်လင့်မိသည်။


# အခန်း (၂) - Structure များ


Go သည် C++ ၊ Java ၊ Ruby နှင့် C# ကဲ့သို့ object-oriented (OO) language တစ်ခုမဟုတ်ပေ။ ၎င်းတွင် object ကော inheritance တို့မပါဝင်သဖြင့် OO နှင့်တွဲဖက်ပါရှိသော polymorphism နှင့် overloading concept များပါရှိမည် မဟုတ်ချေ။

Go တွင်ရှိသည်မှာ method များနှင့် ၎င်းတို့နှင့် တွဲစပ်နိုင်သော structure များသာရှိသည်။  ထိုအပြင် ရိုးရှင်းသောလည်း အလုပ်ဖြစ်သည် composition လည်းပါရှိသည်။ ရလဒ်အနေဖြင့် ပို၍ ရိုးရှင်းသော code များ ရေးသားနိုင်မည် ဖြစ်သော်လည်း OO တွင်ပါသည့်များကို တမ်းတကောင်းတမ်းတမိမည် ဖြစ်သည်။ အရင်ကတည်းက အကြီးအကျယ် အငြင်းပွားကြသည့် *composition over inheritance* အကြောင်းရှိသော်လည်း Go သည် ကျွန်တော်အသုံးပြုသော language များအနက် ပထမတစ်ခုကို အသားပေးသော langauage ဖြစ်သည်။

Go သည် သင်ကျွမ်းဝင်နေသော OO ကဲ့သို့ မဟုတ်သော်လည်း structure နှင့် class ကြေညာမှုများသည် ဆင်တူနေကို သတိထားမိမည် ဖြစ်သည်။ ၎င်းကို အောက်ပါ  `Saiyan` structure တွင်တွေ့ရှိနိုင်ပါသည်။


```go
type Saiyan struct {
  Name string
  Power int
}
```

ထိုနောက် ၎င်း structure ကို Class ကဲ့သို့ အသုံးပြုနိုင်အောင် method ဖြင့်မည်သို့ ချိတ်ဆက်မည် များမကြာမီတွေ့ရမည် ဖြစ်ပြီး ယခုတွင် declaration ဘက်ကို ပြန်လှည့်ကြပါစို့။


## Declarations and Initializations

variable နှင့် declaration များကို ပထမလေ့လာမိသလောက်တွေ့ရမည်မှာ မူလသတ်မှတ်ထားသော type များဖြစ်သည့် integers နှင့် string ကိုတွေ့ရမည်ဖြစ်ပြီး ယခု structure များအကြောင်းလေ့လာရာတွင် pointer များအကြောင်းပါ ဆက်စပ်ရှင်းပြရပါမည်။

structure တစ်ခုကို အလွယ်ဆုံးတည်ဆောက်နိုင်ရန်နည်းလမ်းမှာ


```go
goku := Saiyan{
  Name: "Goku",
  Power: 9000,
}
```

*သတိပြုရန်* အထက်က ဥပမာတွင် `,`  သည်မပါမဖြစ်ဖြစ်ပြီး မပါက compiler မှ error ပြမည်ဖြစ်သည်။ သင့်အနေဖြင့် ပါလိုက်မပါလိုက်ဖြစ်ပါက ရသော language များနှင့်နှိုင်းစာရင် သဘောကျလိမ့်မည်မဖြစ်သည်။ field အတွင်းရှိ value တစ်ခုမှ မသတ်မှတ်သော်လည်းရသည်။ ထိုကြောင့် အောက်မှ ဥပမာ နှစ်ခုလုံး အလုပ်လုပ်မည် ဖြစ်သည်။


```go
goku := Saiyan{}

// or

goku := Saiyan{Name: "Goku"}
goku.Power = 9000
```

field များသည်လည်း variable များကဲ့သို့ပင် assign မလုပ်ထားပါက နတ္တိ တန်ဖိုး သတ်မှတ်ထားသည်။
ထိုအပြင် field name များကို ကျော်၍ declaration order အတိုင်း assgin လုပ်နိုင်သော်လည်း ရှင်းရှင်းလင်းလင်းဖြစ်စေရန် field အနည်းငယ်ဖြစ်မှသာ အောက်ပါအတိုင်း ပြုလုပ်သင့်သည်။


```go
goku := Saiyan{"Goku", 9000}
```
အပေါ်မှ ဥပမာတွင် `goku` ဟုသော variable ကိုတည်ဆောက်ကာ assign ပြုလုပ်လိုက်ခြင်း ဖြစ်သည်။
အချိန်တော်တော်များများတွင် ကျွန်တော်တို့၏ variable ကို value ဖြင့်တိုက်ရိုက် ချိတ်ဆက်ခြင်းပြုလုပ်သည်ထက် pointer တစ်ခုအနေဖြင့် ညွန်းဆိုသည်က များသည်။ pointer သည် value တည်ရှိသော memory address ကိုညွန်ပြပေးသည့် location ဖြစ်သည်။ အိမ်နှင့် အိမ်၏တည်နေရာပြသော မြေပုံ မတူညီသကဲ့သို့ပင်။

အဘယ်ကြောင့် တကယ့် value ထက်စာလျှင် value ကိုညွန်ပြပေးသော point ကိုလိုအပ်သနည်း? Go သည် function သို့ argument အနေဖြင့် ပို့လွတ်သောအခါ copy အနေဖြင့်ပို့လွတ်သောကြောင့်ဖြစ်သည်။ ထိုကြောာင့် အောက်က code တွင်မည်သို့ ပေါ်မည်နည်း။

```go
func main() {
  goku := Saiyan{"Goku", 9000}
  Super(goku)
  fmt.Println(goku.Power)
}

func Super(s Saiyan) {
  s.Power += 10000
}
```

အဖြေမှာ 19000 မဟုတ်ပဲ 9000 ဖြစ်မည်။ `Super` ဟုသော function သည် original `goku` variable မှတန်ဖိုးကိုယူသည်မဟုတ်ပဲ copy ပွားယူသောကြောင့် `Super` မှ လုပ်ဆောင်သည် ၎င်း function ကိုခေါ်သူအတွက် အသက်ဝင်မည်မဟုတ်ပေ။ သင်လိုချင်သည့် အတိုင်းအလုပ်လုပ်စေလိုပါ pointer value ကိုသာ ပို့ပေးရန်လိုသည်။

```go
func main() {
  goku := &Saiyan{"Goku", 9000}
  Super(goku)
  fmt.Println(goku.Power)
}

func Super(s *Saiyan) {
  s.Power += 10000
}
```

အပေါ်နှင့်မတူသည်က ပြောင်းလဲမှု နှစ်ခုပြုလုပ်ထားသည်။ ပထမတစ်ခုက `&` ဟု operator ကိုအသုံးပြုကာ value ၏ address ကိုလှမ်းယူလိုက်သည်ဖြစ်သည်။ ထိုနောက် `Super` မှ လက်ခံသော paramater ကိုပြောင်းလဲလိုက်သည်။ မူလ အစတွင် `Saiyan` အမျိုးအစား၏ value ကိုမျှော်လင့်မည်ဖြစ်သော်လည်း ယခုတွင် `*Saiyan` ၏ adress တနည်းအားဖြင့် `*X` ဟုဆိုလိုသည်မှာ *X အမျိုးအစား၏ pointer* ကိုဆိုလိုခြင်းဖြစ်သည်။ `Saiyan` နှင့် `*Saiyan` မှာ သေချာပေါက် ဆက်နွယ်သော်လည်း ကွဲပြားသော type ဖြစ်သည်။

သို့သော် `goku` value ကို copy ပြုလုပ်၍ပို့ခြင်းပင်ဖြစ်သော်လည်း `Super` မှလက်ခံရရှိသော value သည် address ဖြစ်သွားသောကြောင့်ဖြစ်သည်။ copy နှင့် မူရင်းသည် address အတူတူပင်ဖြစ်သောကြောင့် မူလတန်ဖိုးတွင် ပြောင်းလဲသွားခြင်းဖြစ်သည်။ ဥပမာ အနေဖြင့် စားသောက်ဆိုင် တစ်ဆိုင် လမ်းကြောင်း ဟု မှတ်ယူနိုင်သည်။ လက်ထဲတွင်ရှိသော value သည်မတူညီသော်လည်း စာသောက်ဆိုင် ၏ နေရာကို ညွန်ပြနေသည်ကတော့ အတူတူပင်ဖြစ်သည်။

၎င်းကို pointer နေရာကိုပြောင်းလဲကြည့်ခြင်းဖြင့် copy ပြုလုပ်ကြောင်းသိသာ ထင်ရှားစေနိုင်သည်။ (လက်တွေ့တွင်တော့ သင့်လုပ်လိုသော ပုံစံမျိုးမဟုတ်ပါ) 

```go
func main() {
  goku := &Saiyan{"Goku", 9000}
  Super(goku)
  fmt.Println(goku.Power)
}

func Super(s *Saiyan) {
  s = &Saiyan{"Gohan", 1000}
}
```

အပေါ်မှ ဥပမာတွင် 9000 ကိုသာ print လုပ်မည်ဖြစ်သည်။ ၎င်းသည် Ruby ၊ Python ၊ Java ၊ C# တို့နှင့်အတူတူပင်ဖြစ်ပြီး Go နှင့် C# ၏ အချို့အပိုင်းများတွင်သာ ထိုအချက်သည် သိသာစေနိုင်သည်။

point တစ်ခုကို သယ်ယူခြင်းသည် ရှုပ်ထွေးလှသော structure တစ်ခုလုံးကို သယ်ယူခြင်းနှင့် နှိုင်းစာလျှင့် ပို၍ ပေါ့ပါးသည်ဖြစ်သည် ကို သတိပြုရမည်ဖြစ်သည်။ 64bit စက်များတွင် pointer ၏ size သည် 64bit 
ဖြစ်သည်။ အကယ်၍ fields များစွာပါဝင်သော structure ဖြစ်ပါက copy ပြုလုပ်ခြင်းသည် မသက်သာလှပေ။ 
pointer မှတဆင့် တကယ်လက်ရှိ value ကိုညွန်းဆို၍ အလုပ်လုပ်နိုင်ပြီ ဖြစ်၍ `Super` function မှ `goku` တစ်ခုလုံးကို copy ပြုလုပ်၍ပို့ ပြောင်းလဲပြီး ပြန်လက်ခံစရာ ကော လိုသေးပါရဲ့လား?

သို့သော် အမြဲတမ်း pointer သုံးရမည်ဟု ဆိုလိုခြင်းမဟုတ်ပေ။ ယခု အခန်း၏ အဆုံးသတ်တွင် structure နှင့်ဘာတွေလုပ်နိုင်မည်ကို သိရှိပြီး နောက်တွင်မူ pointer နှင့် value တို့အကြားအားပြိုင်ချက်ကို ထပ်၍ ပြန်ရှုပါဦးမည်။


## Structure ပေါ်မှ function များ

method နှင့် structure ကိုအောက်ပါအတိုင်း တွဲစပ်နိုင်သည်။

```go
type Saiyan struct {
  Name string
  Power int
}

func (s *Saiyan) Super() {
  s.Power += 10000
}
```
အပေါ်က ဥပမာတွင် `*Saiyan` ကို `Super` ၏ လက်ခံရရှိမည့်သူဖြစ်ကြောင်း ကြေညာလိုက်သည်။ ထိုကြောင့် `Super`
ကိုအောက်ပါ အတိုင်း ခေါ်ယူနိုင်သည်။ 

```go
goku := &Saiyan{"Goku", 9001}
goku.Super()
fmt.Println(goku.Power) // will print 19001
```

## Constructors

Structure တွင် constructors များမပါဝင်ပါ။ ၎င်းအစား မိမိတို့လိုချင်သည့်အတိုင်း instance ကို return ပြန်ပေးသော function တစ်ခု တည်ဆောက်နိုင်ပါသည်။ (Factory pattern)


```go
func NewSaiyan(name string, power int) *Saiyan {
  return &Saiyan{
    Name: name,
    Power: power,
  }
}
```

ထို pattern သည် developer အတော်များများ အကြား စကားပြောစရာဖြစ်လာသည်။ တဖက်က ကြည့်ပါ စာသားပြောင်းလဲမှု အနည်းငယ် ကိုတွေးစရာရှိသောလည်း တဖက်တွင် ပို၍ စည်းစနစ်မကျ သလို မှတ်ယူကြသည်။ Factory တွင် pointer မပါသောလည်း ရပါသည်။


```go
func NewSaiyan(name string, power int) Saiyan {
  return Saiyan{
    Name: name,
    Power: power,
  }
}
```

## New

Contructor မရှိသောလည်း type များအတိုင်း memory တွင် သတ်မှတ်နေရာယူရန် Go တွင် built-in function ဖြစ်သော `new` ပါရှိသည်။ `new(X)` သည် `&X{}` နှင့်အတူတူပင်ဖြစ်သည်။

```go
goku := new(Saiyan)
// same as
goku := &Saiyan{}
```

မိမိတို့နှစ်သက်ရာကို အသုံးပြုနိုင်သောလည်း အတော်များများမှာ fields မှာ initialize ပြုလုပ်နိုင်ပြီး ဖတ်ရလွယ်ကူသည့် ဒုတိယ နည်းလမ်းကို အသုံးများကြသည်။

```go
goku := new(Saiyan)
goku.name = "goku"
goku.power = 9001

//vs

goku := &Saiyan {
  name: "goku",
  power: 9000,
}
```

မည်သည့်နည်းလမ်းကို ရွေးသည်ဖြစ်စေ အပေါ်မှ factory pattern ကိုအသုံးပြုပါက သင့်အနေဖြင့် allocation ပတ်သတ်သော သောကများကို ကာကွယ်ပေးနိုင်သည်။ 


## Structure တစ်ခု၏ field များ

ဖော်ပြပြီးသော ဥပမာ များအရ `Saiyan` တွင် `Name` နှင့် `Power` ဟုသော `strings` အမျိုးအစားနှင့် `int` အမျိုးအစား field နှစ်ခုရှိသည်ကိုတွေ့ရမည်။ field များသည် structure များ ၊ မပြောရသေးသော array များ၊ map များ interface များ ၊ function များ စသဖြင့် type အမျိုးစုံ ဖြစ်နိုင်သည်။

ဥပမာ `Saiyan` ၏ ဥပမာကို အောက်ပါအတိုင်း ထပ်၍ ဖြန့်ကျက်၍ ရပါသေးသည်။

```go
type Saiyan struct {
  Name string
  Power int
  Father *Saiyan
}
```
၎င်းကို initialize လုပ်လိုပါက

```go
gohan := &Saiyan{
  Name: "Gohan",
  Power: 1000,
  Father: &Saiyan {
    Name: "Goku",
    Power: 9001,
    Father: nil,
  },
}
```

## Composition

Go တွင် structure တစ်ခုမှ အခြားတစ်ခုသို့ ထည့်သွင်းနိုင်သော composition ပါဝင်သည်။ တချို့ language များတွင် trait သို့မဟုတ် mixin ဟုခေါ်လေ့ရှိသည်။ composition ပြုလုပ်နိုင်ခြင်းမရှိသော language များတွင်မူ ခပ်ဆင်ဆင်ဖြစ်အောင် ပြုလုပ်၍ရသောလည်း လွယ်တော့ မလွယ်ကူလှချေ။ Mixin မရှိသော Java တွင် *inheritance* ကိုအသုံးပြု၍ structure များကို extend ပြုလုပ်ရန် အောက်ပါ အတိုင်းရေးသား၍ရသည်။

```java
public class Person {
  private String name;

  public String getName() {
    return this.name;
  }
}

public class Saiyan {
  // Saiyan is said to have a person
  private Person person;

  // we forward the call to person
  public String getName() {
    return this.person.getName();
  }
  ...
}
```
သို့သော် တခါတရံ အာရုံနောက်လာနိုင်ပေသည်။ `Person` တွင်ရှိသော method တိုင်းသည် `Saiyan` အတွက်ပါ ရှိနေရန် လိုအပ်နေမည်ဖြစ်သည်။ Go တွင် ထိုသို့သော ကိစ္စမျိုးကို အောက်ပါအတိုင်း

```go
type Person struct {
  Name string
}

func (p *Person) Introduce() {
  fmt.Printf("Hi, I'm %s\n", p.Name)
}

type Saiyan struct {
  *Person
  Power int
}

// and to use it:
goku := &Saiyan{
  Person: &Person{"Goku"},
  Power: 9001,
}
goku.Introduce()
```

`Saiyan` structure တွင် `*Person` type ၏ field တစ်ခုပါရှိပြီး field တစ်ခုအနေဖြင့် အမည်ပေးထားခြင်းမရှိသောကြောင့် compose ပြုလုပ်ထားသော type အတွင်းရှိ fields နှင့် method များကို အသုံးပြုနိုင်သည်။ သို့သော် Go compiler အနေဖြင့် field name များ *အလိုအလျောက်* သတ်မှတ်ပေးထားသည်။ 
ထိုကြောင့် အောက်ပါအတိုင်း လှမ်းခေါ်နိုင်သည်။


```go
goku := &Saiyan{
  Person: &Person{"Goku"},
}
fmt.Println(goku.Name)
fmt.Println(goku.Person.Name)
```

အပေါ်မှ နှစ်ခုလုံး "Goku" ဟု print ပြုလုပ်မည်ဖြစ်သည်။ Composition က Inheritance ထက်ပိုကောင်းသလား။ လူအတော်များများကတော့ code ကိုပြန်လည်အသုံးပြုရာတွင် ပို၍ ခိုင်မာသည်ဟု ယူဆကြသည်။ inheritance ကိုအသုံးပြုပါက သင့်၏ class သည် parent class ဖြင့် တင်းကျပ်စွာ ချည်နှောင်ထားသလိုဖြစ်၍ behavior ထက်နိုင်းစာလျှင် hierarchy ဘက်ကို ပို၍ အလေးစိုက်ရဖွယ်ဖြစ်သည်။

### Overloading

Overloading ကို structure များတွ်သာ အသုံးပြုနိုင်သည် မဟုတ်သော်လည်း ၎င်းကိုရှင်းပြရန်လိုအပ်သည်။ Go တွင် overloading ကို support မလုပ်ပါ။ ထိုအတွက်အကြောင့် `Load` ၊ `LoadById` ၊ `LoadByName` စသဖြင့် ပုံစံများကို ရေးရမြင်ရမည် ဖြစ်သည်။

သို့သော် တိုက်ရိုက် composition မှာ compiler ၏လှည့်ကွက် တစ်ခုဖြစ်ပြီး function တစ်ခု၏ compose type ကို overwrite ပြုလုပ်၍ရနိုင်သည်။ ဥပမာ `Saiyan` structure တွင်း ၎င်းကိုယ်ပိုင် `Introduce` function ရှိပါက

```go
func (s *Saiyan) Introduce() {
  fmt.Printf("Hi, I'm %s. Ya!\n", s.Name)
}
```

composed version အနေဖြင့် `s.Person.Introduce()` ဟု၍လှမ်းခေါ်နိုင်သည်။

## Pointers versus Values

Go ကိုရေးနေရင်း *value သုံးရမလား pointer သုံးရမလား* ဆိုတာ ဇဝေဇဝါဖြစ်တဲ့သူတွေ အတွက် သတင်းကောင်းနှစ်ခုရှိပါတယ်။ ပထမ တစ်ခုကတော့ အောက်ပါ အခြေအနေများအတွက် ဘယ်ဟာသုံးသုံးအတူတူပါပဲ။

* local variable သတ်မှတ်ခြင်း
* structure ထဲမှ field 
* function တစ်ခုမှ return ပြန်သည့်တန်ဖိုး
* function တစ်ခုသို့ parameter
* method တစ်ခုသို့ လက်ခံရယူခြင်း

ဒုတိယ တစ်ခုအနေနဲ့ကတော့ မသေချာရင် pointer သာသုံးပါ။
မြင်ခဲ့သည့်အတိုင်း value ကို pass ခြင်းဖြင့် data ကို immutable ပြုလုပ်ရာတွင် ကောင်းမွန်သလို တခါတလေကြရင် ထိုအခြေအနေမျိုးလိုအပ်မည်ဖြစ်သောလည်း များသောအားဖြင့် မလိုလှပေ။

data ကိုပြောင်းလဲလိုခြင်းမရှိသောလည်း large structure တစ်ခုကို copy ပြုလုပ်ပါက ကျသင့်သည့်တန်ဖိုးကို စဉ်းစားသင့်ပါသည်။ ထိုနည်းတူ အောက်ပါကဲ့သို့သော သေးငယ် structure များအတွက်မူ

```go
type Point struct {
  X int
  Y int
}
```
copy လုပ်သောအခါ ကုန်သည့်တန်ဖိုးထက်နှိုင်းစာလျင် `x` နှင့် `y` တို့ကို တိုက်ရိုက် access ပြုလုပ်နိုင်ခြင်းက ပို၍ အားသာပါလိမ့်မည်။

ထပ်၍ ပြောရပါလျင် ၎င်းတို့သည် သိမ်မွေ့သော ပြဿနာဖြစ်သည်။ သင့်အနေဖြင့် ထိုသို့ကဲ့သို့ ထောင်သောင်းချီသော point လုပ်စရာမလိုပါက ကွဲပြားခြားနားချက်ကို သတိထားမိမည် မဟုတ်ပေ။

## နောက်အခန်း မဖတ်ခင်

ယခုအခန်းတွင် structure များအကြောင်း မိတ်ဆက်ပေးခဲ့ပြီး function တစ်ခုလက်ခံနိုင်သော structure တစ်ခု မည်သို့ တည်ဆောက်မည်နည်း ၊ Go ၏ type စနစ်တွင်ပါဝင်သည့် pointer များနှင့်ပတ်သတ်၍ ထပ်ဆင့်လေ့လာပြီးဖြစ်၍ နောက် အခန်းတွင်မူ stucture များအချင်းချင်း မည်သို့အလုပ်လုပ်သည်ကို ဆက်၍လေ့လာသွားမည်ဖြစ်သည်။

# အခန်း (၃) - Maps ၊ Arrays နှင့် Slices

အခုထက်ထိတော့ ပုံမှန် type နဲ့ structure များအကြောင်းလေ့လာပြီးနောက် ဒီအခန်းမှာတော့ array များ slice များနှင့် map များအကြောင်းကို ရှင်းပြသွားမှာဖြစ်ပါတယ်။

## Arrays

Python ၊ Ruby ၊ Perl ၊ Javascript တို့ PHP ကဲ့သို့သော language များကိုလေ့လာခဲ့ပါက *dynamic array* များနှင့် ရင်းနှီးနေမည်ဖြစ်သည်။ ထို array များသည် data များထည့်သွင်းသည်နှင့်အမျှ ပြန်လည် ချိန်ညှိပေးသည်။ Go တွင်မူ အပေါ်မှ အပ အခြား language များကဲ့သို့ array မှာ အသေဖြစ်သည်။ array ကိုကြေညာသည်နှင့် ဆိုဒ်မှာ အသေဖြစ်ပြီး တိုး၍မရတော့ပေ။

```go
var scores [10]int
scores[0] = 339
```

အထက်တွင်ဖော်ပြထားသော array တွင် `score[0]` မှ `score[9]` အထိ index ဆယ်ခုစာ ထည့်သွင်းနိုင်သည်။ ထိုမှအပ အခြား index များကိုခေါ်ပါက compiler သို့မဟုတ် runtime error တက်လိမ့်မည်။ Array ကို value များပါတပါတည်း အောက်ပါအတိုင်း ကြေညာနိုင်သည်။

```go
scores := [4]int{9001, 9333, 212, 33}
```

`len` ကိုအသုံးပြု၍ array ၏ အရှည်ကိုသိနိုင်သလို `range` ကိုအသုံးပြု၍ loop ပတ်နိုင်သည်။

```go
for index, value := range scores {

}
```

Array မှာ အလွန်အသုံးဝင်သောလည်း တင်းကျပ်သည်။ ပုံမှန်အားဖြင့် မိမိတို့ လိုအပ်သည့် element အရေအတွက်ကို မသိရှိနိုင်ချိန်တွင် Array အစား Slice ကိုအသုံးပြုသည်။ 


## Slices

Go တွင် array ကိုတိုက်ရိုက် အသုံးပြုရသည်က ရှားသည်။ ထိုအစား slice ကိုအသုံးပြုကြသည်။ slice သည် array ပုံစံအတိုင်း ဖော်ပြနိုင်သည့် structure တစ်ခုဖြစ်သည်။ slice ကိုတည်ဆောက်နိုင်ရန် နည်းလမ်းမှာ တစ်ခုထက်မကရှိပြီး မည့်သည်အချိန်တွင် သုံးရမည်ကို နောက်တွင် ဆက်ပြောပါမည်။ ရှေးဦးစွာ ဖန်တီးသည့် နည်းလမ်းကွဲများ ကိုအရင် ရှင်းပြပါမည်။


```go
scores := []int{1,4,293,4,9}
```

Array နှင့်မတူသည်က လေးထောင့်ကွင်းထဲ ၎င်း၏ အရှည်ကို မသတ်မှတ်ပေးရပါ။ ကွဲပြားခြားနားသည်ကို သိနိုင်ရင် slice ကိုဖန်တီးနိုင်သည့် နောက်တစ်မျိုးဖြစ်သည့် `make` ကိုအသုံးပြုကြပါစို့။

```go
scores := make([]int, 10)
```

`new` အစား `make` ကိုအသုံးပြုရသည့်အကြောင်းမှာ memory တွင် နေရာယူခြင်း သက်သက်သာမဟုတ်ပဲ slice တစ်ခုကို အမှန်တကယ် ဖန်တီးလိုက်ခြင်းကြောင့်ဖြစ်သည်။ ထိုကြောင့် array အတွက် memory နေရာယူရုံသာမက slice အတွက်ပါ ကြေညာလိုက်ခြင်းဖြစ်သည်။ အပေါ်မှ ဥပမာတွင် slice ၏ အရှည်မှာ တစ်ဆယ် ဖြစ်ပြီးထည့်သွင်းနိုင်စွမ်းမှာလည်း ဆယ်ခုဖြစ်သည်။ ထိုနှစ်ခုမှာ မတူညီပါ။ `make` ကိုအသုံးပြု၍ ၎င်းနှစ်ခုကို သီးခြားစီ ထည့်သွင်းနိုင်သည်။

```go
scores := make([]int, 0, 10)
```


၎င်းတွင် slice ၏ အရှည်မှာ သုညဖြစ်ပြီး ထည့်သွင်းနိုင်စွမ်းမှာ တစ်ဆယ်ဖြစ်သည်။ သတိထားကြည့်ပါက `make` နှင့် `len` များသည် overload ပြုလုပ်ထားသည်ကို သတိထားမိမည်ဖြစ်သည်။ Go သည် developer များအသုံးပြုနိုင်အောင် ထုတ်မပေးသောလည်း language designer များက အသုံးပြုနေသည်ကိုတွေ့နေရသောကြောင့် တချို့မှာ အမြင်မကြည်ကြပေ။


အရှည်နှင့် ထည့်သွင်းနိုင်စွမ်းကို ကွဲပြားစေရန် အောက်ပါ ဥပမာကိုကြည့်ပါ။

```go
func main() {
  scores := make([]int, 0, 10)
  scores[7] = 9033
  fmt.Println(scores)
}
```

Crash ဖြစ်ပါလိမ့်မည်။ အဘယ်ကြောင့်ဆိုသော် slice ၏ အရှည်မှာ 0 ဖြစ်သောကြောင့်ဖြစ်သည်။ ၎င်း၏ လက်အောက်ခံ array မှာ ဆယ်ခုရှိမည်ဖြစ်သော်လည်း  ထို element များကိုခေါ်ယူအသုံးပြုနိုင်ရန် slice ကိုတိုးချဲ့မှရမည်။ slice ကို ချဲ့နိုင်မည့် နည်းလမ်း တစ်ခုမှာ `append` ကိုအသုံးပြုခြင်းဖြစ်သည်။

```go
func main() {
  scores := make([]int, 0, 10)
  scores = append(scores, 5)
  fmt.Println(scores) // prints [5]
}
```


သို့သော် ထိုသို့ပြောင်းလိုက်ခြင်းဖြင့် မူလ code ၏ရည်ရွယ်ချက် ပါပြောင်းသွားမည်ဖြစ်ပြီး အရှည် 0 ရှိသော slice ၏ နောက်မှ ထပ်ထည့်သည်ထက် အခန်း နံပါတ် (၇) တွင်ထည့်လိုသည်ဖြစ်၍ slice ကိုထပ်၍ ပိုင်းနိုင်ပါသည်။


```go
func main() {
  scores := make([]int, 0, 10)
  scores = scores[0:8]
  scores[7] = 9033
  fmt.Println(scores)
}
```

slice တစ်ခုကို ဘယ်လောက်ပြန်၍ resize လုပ်နိုင်ပါသလဲ။ ယခုကိစ္စတွင် တစ်ဆယ် ဖြစ်သည်။ သင့်အနေဖြင့် ယခုအတိုင်းလုပ်ခြင်းဖြင့် *array များကဲ့သို့ အသေဖြစ်နေသည့် ပြဿနာမှာ သိပ်ပြီးမထူး* ဟု ထင်ကောင်ထင်လိမ့်မည်။ `append` တွင်ထူးခြားသည်က array ပြည့်နေပါက ပို၍ကြီးမားသော array တစ်ခုတည်ဆောက်ပြီး value များကိုပါ သယ်ဆောင်ပေးမည်ဖြစ်သည်။ (၎င်းပုံစံ PHP ၊ Python ၊ Ruby ၊ Javascript တွင် dynamic array များ အလုပ်လုပ်ပုံနှင့် အတူတူပင်ဖြစ်သည်။ ) ထို့ကြောင့် `append` မှ ပြန်လာသော တန်ဖိုးကို လက်ခံနိုင်ပြီး assign ပြန်လုပ်ပေးနိုင်သည်။ `score` variable တွင်ရှိသော array မှာ original မှနေရာမရှိတော့ပါက copy ကူးယူထားသော အသစ်တန်ဖိုးဖြစ်သည်။ 

အကယ်၍ Go ၏ array များသည် ဆတူတိုးသွားသည်ဆိုပါက အောက်ပါ code သည် မည်သို့ဖော်ပြမည်နည်း?


```go
func main() {
  scores := make([]int, 0, 5)
  c := cap(scores)
  fmt.Println(c)

  for i := 0; i < 25; i++ {
    scores = append(scores, i)

    // if our capacity has changed,
    // Go had to grow our array to accommodate the new data
    if cap(scores) != c {
      c = cap(scores)
      fmt.Println(c)
    }
  }
}
```
ပထမဆုံး `score` ၏ သိမ်းဆည်းနိုင်သော ပမာဏသည် ငါးခုဖြစ်မည်။ နှစ်ဆယ့်ငါးခုကို သိမ်းဆည်နိုင်ရန် ဆယ်ခု ၊ အခုနှစ်ဆယ် နှင့် နောက်ဆုံး အခု လေးဆယ် အထိ ဆတူ တိုးသွားမည်ဖြစ်သည်။ နောက်ဆုံး ဥပမာ အနေဖြင့် အောက်က code ကိုကြည့်ပါ။


```go
func main() {
  scores := make([]int, 5)
  scores = append(scores, 9332)
  fmt.Println(scores)
}
```

`[0, 0, 0, 0, 0, 9332]` ဟုထွက်မည်ဖြစ်သည်။ သင့်အနေဖြင့်  `[9332, 0, 0, 0, 0]` ဟုလိုချင်ကောင်းလိုချင်လိမ့်မည်။ လူအတွက်တော့ ဟုတ်ကောင်းဟုတ်မည်ဖြစ်သော်လည်း တန်ဖိုးများရှိပြီးသော slice အတွက် compile သည်ထိုသို့ ပြုမူပါလိမ့်မည်။

slice တစ်ခုကိုတည်ဆောက်ရန် နည်းလမ်းလေးမျိုးရှိသည်။

```go
names := []string{"leto", "jessica", "paul"}
checks := make([]bool, 10)
var names []string
scores := make([]int, 0, 20)
```

ဘယ်အချိန်မှာ ဘယ်ဟာကိုသုံးရမလဲ? ပထမတစ်ခုအနေဖြင့် သိပ်ရှင်းရန်မလိုပါ။ value များကိုကြိုသိချိန်တွင်သုံးနိုင်သည်။

ဒုတိယနည်းလမ်း ကို index များကို တန်ဖိုးထည့်သွင်းရာအသုံးပြုနိုင်သည်။ ဥပမာ

```go
func extractPowers(saiyans []*Saiyan) []int {
  powers := make([]int, len(saiyans))
  for index, saiyan := range saiyans {
    powers[index] = saiyan.Power
  }
  return powers
}
```

တတိယ အမျိုးအစားကိုမူ element မည်မျှပါဝင်သည်ကို မသိလောက်သည့် အနေအထားတွင်  နတ္တိတန်ဖိုးများချည်းသာပါဝင်သည့် slice ကိုတည်ဆောက်ပြီး `append` ဖြင့်ဖြည့်သွားမည့် ပုံစံဖြင့်သုံးသည်။

နောက်ဆုံး အမျိုးအစားကိုမူ အကြမ်းအားဖြင့် element မည်မျှရှိသည်ကို မှန်းဆနိုင်ပါက မူလတန်ဖိုး ထည့်သွင်းရာတွင် အသုံးဝင်သည်။

ပမာဏကို သိသည့်အခါတွင်လည်း `append` ကိုအသုံးပြုနိုင်သည်။ မိမိတို့ နှစ်သက်ရာပုံစံသာ ကွဲလေ၏။


```go
func extractPowers(saiyans []*Saiyan) []int {
  powers := make([]int, 0, len(saiyans))
  for _, saiyan := range saiyans {
    powers = append(powers, saiyan.Power)
  }
  return powers
}
```

Slice သည် array များ အပေါ်မှ ဖုံးအုပ်ထားသော အလွှာတစ်ခုဖြစ်ပြီး အလွန်အသုံးဝင်သည်။ Language တော်တော်များများတွင် array ကိုပိုင်းဖြတ်သည့် concept များပါရှိသည်။ Javascript နှင် Ruby တွင် array များသည် `slice` method ပါရှိသည်။ Ruby တွင် `[START..END]` ဟုသော်လည်းကောင်း Python တွင် `[START:END]`
ဟုလည်းကောင်း အသုံးပြု၍ ပိုင်းဖြတ်နိုင်သည်။ သို့သော် ထို language များတွင် slice သည် မူလတန်ဖိုးများ ကူးယူထားသော array အသစ်တစ်ခုသာဖြစ်သည်။ Ruby တွင် အောက်ပါ code ၏ ရလဒ်မှာ ဘာဖြစ်မည်နည်း။


```ruby
scores = [1,2,3,4,5]
slice = scores[2..4]
slice[0] = 999
puts scores
```
အဖြေမှာ `[1, 2, 3, 4, 5]` ဖြစ်မည်။ အဘယ်ကြောင့်ဆိုသော် `slice` သည် array အသစ်အနေဖြင့် copy ကူးသွား၍ ဖြစ်သည်။ Go မှာထိုကဲ့သို့ပြုလုပ်ပါက


```go
scores := []int{1,2,3,4,5}
slice := scores[2:4]
slice[0] = 999
fmt.Println(scores)
```

အဖြေမှာ  `[1, 2, 999, 4, 5]` ဖြစ်မည်။


ထိုပြောင်းလဲခြင်းက ကုဒ်ရေးသည့်ပုံစံပါ ပြောင်းလဲသွားသည်။ ဥပမာ function များသို့ parameter ပို့သောအခါ။ javascript တွင် string တစ်ခု၏ အက္ခရာ ငါးခု ကျော်ပြီး နေရာကို လိုပါက (slice သည် string များတွင်လည်း အလုပ်လုပ်သည်) 


This changes how you code. For example, a number of functions take a position parameter. In JavaScript, if we want to find the first space in a string (yes, slices work on strings too!) after the first five characters, we'd write:

```javascript
haystack = "the spice must flow";
console.log(haystack.indexOf(" ", 5));
```

Go တွင် slice ကိုအောက်ပါ အတိုင်းသုံးနိုင်သည်။


```go
strings.Index(haystack[5:], " ")
```


အထက်ဖော်ပြပါ ဥပမာများမှ  `[X:]` သည် *X မှစ၍ အဆုံးထိ* ဟု အဓိပ္ပါယ်ရပြီး `[:X]` သည် *အစမှ X အထိသို့* ဟု အဓိပ္ပါယ် သက်ရောက်သည်။ တခြား language များနှင့်ကွာခြားသည်က Go တွင် အနုတ်ကိန်းများကို support မလုပ်ချေ။ အကယ့်၍ နောက်ဆုံးတစ်ခုလွဲ၍ ကျန်သော် value များကို အလိုရှိပါက အောက်ပါအတိုင်းရေးရသည်။

```go
scores := []int{1, 2, 3, 4, 5}
scores = scores[:len(scores)-1]
```

အပေါ်မှ ဥပမာသည် unsorted slice များ value များကို ဖယ်ထုတ်ရာတွင် အသက်သာဆုံး နည်းလမ်းဖြစ်သည်။

```go
func main() {
  scores := []int{1, 2, 3, 4, 5}
  scores = removeAtIndex(scores, 2)
  fmt.Println(scores) // [1 2 5 4]
}

// won't preserve order
func removeAtIndex(source []int, index int) []int {
  lastIndex := len(source) - 1
  //swap the last value and the value we want to remove
  source[index], source[lastIndex] = source[lastIndex], source[index]
  return source[:lastIndex]
}
```

နောက်ဆုံးတွင် slice များအကြောင်း သိရှိပြီး ဖြစ်၍ မူလကတည်းက ပါဝင်သော function တစ်ခုဖြစ်သည့် `copy` ကိုကြည့်ပါစို့။ `copy` သည် slice များကြောင့် ကုဒ်ရေးရပုံ အပြောင်းအလဲကို မီးမောင်းထိုးပြနိုင်သည့် ဥပမာ တစ်ခုဖြစ်သည်။ ပုံမှန်အားဖြင့် array တစ်ခုမှ နောက်တစ်ခုသို့ copy ပြုလုပ်ရန် parameter ငါးခုလိုအပ်သည်။ ၎င်းတို့မှာ `source` ၊ `sourceStart`၊ `count` ၊ `destination` နှင့် `destinationStart` တို့ဖြစ်သည်။
Slice ကိုအသုံးပြုပါက နှစ်ခုသာလိုအပ်သည်။


```go
import (
  "fmt"
  "math/rand"
  "sort"
)

func main() {
  scores := make([]int, 100)
  for i := 0; i < 100; i++ {
    scores[i] = int(rand.Int31n(1000))
  }
  sort.Ints(scores)

  worst := make([]int, 5)
  copy(worst, scores[:5])
  fmt.Println(worst)
}
```


အချိန်ခဏယူ၍ အထက်ပါ code ကိုနားလည်အောင် ကြည့်ပါ။ တစ်ချို့ အပိုင်းများကို ပြောင်းလဲကြည့်ပါ။ copy ကို `copy(worst[2:4], scores[:5])` ပြောင်းကြည့်ပါက ဘာဖြစ်မည်နည်း။ value ငါးခုထက် နည်းသော တန်ဖိုးများကို `worst` သို့ ကူးကြည့်ပါက ဘာဖြစ်မည်နည်း။

## Maps

Go တွင်ပါရှိသော Map သည် အခြား language များတွင် hashtable သို့မဟုတ် dictionary ဟုခေါ်လေ့ရှိပြီး အလုပ်လုပ်ပုံမှာ အတူတူပင်ဖြစ်သည်။ key value မှာ သတ်မှတ် ၊ ခေါ်ဆို ၊ ဖျက်ပစ်ရာတွင် အသုံးပြုသည်။

Maps များသည် slice ကဲ့သို့ပင် `make` function ကိုအသုံးပြုနိုင်သည်။ အောက်က ဥပမာကို ကြည့်ကြည့်ပါ။


```go
func main() {
  lookup := make(map[string]int)
  lookup["goku"] = 9001
  power, exists := lookup["vegeta"]

  // prints 0, false
  // 0 is the default value for an integer
  fmt.Println(power, exists)
}
```

key အရေအတွက်ကိုသိလိုပါက `len` ကိုအသုံးပြုနိုင်ပြီး key တစ်ခုကိုဖျက်လိုပါက `delete` ကိုအသုံးပြုနိုင်သည်။

```go
// returns 1
total := len(lookup)

// has no return, can be called on a non-existing key
delete(lookup, "goku")
```
Map သည် အကန့်အသတ်မရှိသောလည်း သတ်မှတ်လိုပါက  `make` ကိုအသုံးပြုနိုင်သည်။

```go
lookup := make(map[string]int, 100)
```

Map တွင် key မည်မျှရှိလောက်မည်ကို ခန့်မှန်းနိုင်ပါက size သတ်မှတ်ခြင်းဖြင့် performance ပိုကောင်းလာမည်ဖြစ်သည်။

structure တစ်ခု၏ field အနေဖြင့်သတ်မှတ်လိုပါက အောက်ပါအတိုင်း ကြေညာနိုင်သည်။

```go
type Saiyan struct {
  Name string
  Friends map[string]*Saiyan
}
```

အပေါ်မှ ကြေညာထားသည်ကို အောက်ပါအတိုင်း ခေါ်ယူအသုံးပြုနိင်သည်။

```go
goku := &Saiyan{
  Name: "Goku",
  Friends: make(map[string]*Saiyan),
}
goku.Friends["krillin"] = ... //todo load or create Krillin
```
Array များနည်းတူ Go တွင် map များကို `make` ကိုအသုံးပြုနိုင်သလို literal အနေဖြင့်လည်း ကြေညာသတ်မှတ်နိုင်သည်။ 

```go
lookup := map[string]int{
  "goku": 9001,
  "gohan": 2044,
}
```
ထိုနည်းတူ `for` loop များတွင်လည်း `range` ကိုအသုံးပြုနိုင်သည်။

```go
for key, value := range lookup {
  ...
}
```
Map အတွင်းရှိ iteration များသည် စီထားသည် မဟုတ်ပဲ random အလိုက် key value pair များကြလာမည်ဖြစ်သည်။

## Pointers versus Values

အခန်း (၂) တွင် pointer နှင့် value များကွဲပြားချက်ကို လေ့လာပြီးဖြစ်သည်။ ယခု array နှင့် map များအပေါ်တွင် ဆက်၍လေ့လာစရာရှိပါသေးသည်။ အောက်ပါ ပုံစံနှစ်ခု အနက် မည်သည်ကို ပို၍ အသုံးပြုသင့်သနည်း။

```go
a := make([]Saiyan, 10)
//or
b := make([]*Saiyan, 10)
```

developer အတော်များများသည် `b` သည်ပို၍ efficient ဖြစ်မည်ဟုထင်ကြလိမ့်မည်။ သို့သော် return ပြန်လာသော value သည် reference ဖြစ်စေကာမူ slice ၏ copy လုပ်ထားသော value ပင်ဖြစ်ဦးမည်။ ထိုကြောင့် slice ကို pass နှင့် return ပြန်ရာတွင် ကွာခြားမှုမရှိပါ။

သို့သော် slice သို့မဟုတ် map ၏ value များကို ပြင်ပါက ကွာခြားချက်များကိုတွေ့ရမည်ဖြစ်သည်။ ထိုအချိန်တွင်မူ အခန်း (၂) တွင်ပြောသကဲ့သို့ ဖြစ်သည်။ ထိုကြောင့် array နှင့် map တို့၏ pointer နင့် value ကွာခြားချက်သည် ၎င်းတို့၏ value များအသုံးပြုပုံကိုသာ အဓိက မူတည်နေမည်ဖြစ်သည်။


## နောက်အခန်း မဖတ်ခင်


Go ၏ Array နှင့် Map တို့သည် အခြား language များနှင့်အတူတူပင်ဖြစ်သည်။ dyanmic array များနှင့် အသားကျနေပါက အနည်းငယ်ပြောင်းလဲမည် ဖြစ်သော်လည်း `append` ကိုအသုံးပြုခြင်းဖြင့် အဆင်မပြေမှု အတော်များများ ဖြေရှင်းနိုင်သည်။ Array များကို ကျော်လွန်ပါက slice များကိုတွေ့နိုင်မည်ဖြစ်ပြီး slice များသည် အလွန် အစွမ်းထက်ပြီး သင့် code ၏ ရိုရှင်းမှုကို ထိန်းသိမ်းပေးပါသည်။

သို့သော် အစွန်းထွက်နေသော ကိစ္စတချို့ကိုမူ ဒီစာအုပ်တွင် ထည့်သွင်းထားခြင်းမရှိပါ။ သင့်အနေဖြင့်လည်း ကြုံနိုင်ရန် ခဲယဉ်းသဖြင့် ဖြစ်သည်။ အကယ်၍ ကြုံခဲ့ပါက ယခု အခြေခံများကို အသုံးပြု၍ ဖြေရှင်းနိုင်မည် ဟုယုံကြည်ပါသည်။ 


# အခန်း (၄) - Code အစီအစဉ်ချခြင်းနှင့် Interface များ

ယခု အခန်းတွင် Code များကို မည်သို့ နေရာချထားမည်ကို လေ့လာပါမည်။

## Packages

ရှုပ်ထွေးလှသော library များ၊ system များကို အစီအစဉ်ချနိုင်ရန် Packages များအကြောင်း လေ့လာရန်လိုပါသည်။ 
Go တွင် package name သည် Go Workspace အတွင်းတည်ရှိသည့် folder အမည် ကိုလိုက်နာရ့ါသည်။ အကယ်၍ shopping system တစ်ခုကို တည်ဆောက်ပါက သင့်အနေဖြင့် "shopping" ဟုသော package တစ်ခုဟု အမည်ပေးလိုက်ပြီး file များကို `$GOPATH/src/shopping/` တွင်နေရာချထားရမည် ဖြစ်သည်။

အာလုံးကိုတော့ folder တစ်ခုထဲတွင် ထားချင်မည်တော့ မဟုတ်။ ဥပမာ တချို့ သော database logic များကို folder အနေဖြင့် သက်သက် ခွဲထုတ်ရန်လိုအပ်သည်။ ၎င်းအတွက် ထပ်ဆင့် folder တစ်ခုအနေဖြင့်  `$GOPATH/src/shopping/db` ဟုသတ်မှတ်ပေးရန်လိုအပ်သည်။ ထို folder ၏ အမည်သည် `db` ဟုပေးလျှင်ရသော်လည်း တခြား package မှ access လုပ်လိုပါက `shopping` package အတွင်းမှ ဖြစ်၍ `shopping/db` ဟု import လုပ်ရန်လိုသည်။

တနည်းအားဖြင့် package တစ်ခုကို `package` keyword ဖြင့် အမည်ပေးနိုင်သည်။ single value အနေဖြင့် ဥပမာ "shopping" ဝါ "db" ဟု ပေးနိုင်ပြီး import လုပ်ပါက path လမ်းကြောင်းအတိုင်း import လုပ်ရမည်ဖြစ်သည်။

စမ်းကြည့်ရအောင်။ Go workplace အတွင်းရှိ `src` folder အတွင်းမှ (ကျွန်တော်တို့ မိတ်ဆက်တုံးက စမ်းထားခဲ့သော နေရာများ ) `shopping` ဟု အမည်ရှိသော folder နှင့် ၎င်းအတွင်းတွင် `db` ဟုအမည်ရှိသော folder တစ်ခုကို တည်ဆောက်လိုက်ပါ။ 

`shopping/db` ၏အတွင်းတွင် `db.go` ဟုသော file တစ်ခုကို တည်ဆောက်ပြီး အောက်ပါအတိုင်း ရေးလိုက်ပါ။

```go
package db

type Item struct {
  Price float64
}

func LoadItem(id int) *Item {
  return &Item{
    Price: 9.001,
  }
}
```

Notice that the name of the package is the same as the name of the folder. Also, obviously, we aren't actually accessing the database. We're just using this as an example to show how to organize code.

Now, create a file called `pricecheck.go` inside of the main `shopping` folder. Its content is:

```go
package shopping

import (
  "shopping/db"
)

func PriceCheck(itemId int) (float64, bool) {
  item := db.LoadItem(itemId)
  if item == nil {
    return 0, false
  }
  return item.Price, true
}
```

It's tempting to think that importing `shopping/db` is somehow special because we're inside the `shopping` package/folder already. In reality, you're importing `$GOPATH/src/shopping/db`, which means you could just as easily import `test/db` so long as you had a package named `db` inside of your workspace's `src/test` folder.

If you're building a package, you don't need anything more than what we've seen. To build an executable, you still need a `main`. The way I prefer to do this is to create a subfolder called `main` inside of `shopping` with a file called `main.go` and the following content:

```go
package main

import (
  "shopping"
  "fmt"
)

func main() {
  fmt.Println(shopping.PriceCheck(4343))
}
```

You can now run your code by going into your `shopping` project and typing:

```
go run main/main.go
```

### Cyclical Imports

As you start writing more complex systems, you're bound to run into cyclical imports. This happens when package A imports package B but package B imports package A (either directly or indirectly through another package). This is something the compiler won't allow.

Let's change our shopping structure to cause the error.

Move the `Item` definition from `shopping/db/db.go` into `shopping/pricecheck.go`. Your `pricecheck.go` file should now look like:

```go
package shopping

import (
  "shopping/db"
)

type Item struct {
  Price float64
}

func PriceCheck(itemId int) (float64, bool) {
  item := db.LoadItem(itemId)
  if item == nil {
    return 0, false
  }
  return item.Price, true
}
```

If you try to run the code, you'll get a couple of errors from `db/db.go` about `Item` being undefined. This makes sense. `Item` no longer exists in the `db` package; it's been moved to the shopping package. We need to change `shopping/db/db.go` to:

```go
package db

import (
  "shopping"
)

func LoadItem(id int) *shopping.Item {
  return &shopping.Item{
    Price: 9.001,
  }
}
```

Now when you try to run the code, you'll get a dreaded *import cycle not allowed* error. We solve this by introducing another package which contains shared structures. Your directory structure should look like:

```
$GOPATH/src
  - shopping
    pricecheck.go
    - db
      db.go
    - models
      item.go
    - main
      main.go
```

`pricecheck.go` will still import `shopping/db`, but `db.go` will now import `shopping/models` instead of `shopping`, thus breaking the cycle. Since we moved the shared `Item` structure to `shopping/models/item.go`, we need to change `shopping/db/db.go` to reference the `Item` structure from `models` package:

```go
package db

import (
  "shopping/models"
)

func LoadItem(id int) *models.Item {
  return &models.Item{
    Price: 9.001,
  }
}
```

You'll often need to share more than just `models`, so you might have other similar folder named `utilities` and such. The important rule about these shared packages is that they shouldn't import anything from the `shopping` package or any sub-packages. In a few sections, we'll look at interfaces which can help us untangle these types of dependencies.

### Visibility

Go uses a simple rule to define what types and functions are visible outside of a package. If the name of the type or function starts with an uppercase letter, it's visible. If it starts with a lowercase letter, it isn't.

This also applies to structure fields. If a structure field name starts with a lowercase letter, only code within the same package will be able to access them.

For example, if our `items.go` file had a function that looked like:

```go
func NewItem() *Item {
  // ...
}
```

it could be called via `models.NewItem()`. But if the function was named `newItem`, we wouldn't be able to access it from a different package.

Go ahead and change the name of the various functions, types and fields from the `shopping` code. For example, if you rename the `Item's` `Price` field to `price`, you should get an error.

### Package Management

The `go` command we've been using to `run` and `build` has a `get` subcommand which is used to fetch third-party libraries. `go get` supports various protocols but for this example, we'll be getting a library from Github, meaning, you'll need `git` installed on your computer.

Assuming you already have git installed, from a shell/command prompt, enter:

```
go get github.com/mattn/go-sqlite3
```

`go get` fetches the remote files and stores them in your workspace. Go ahead and check your `$GOPATH/src`. In addition to the `shopping` project that we created, you'll now see a `github.com` folder. Within, you'll see a `mattn` folder which contains a `go-sqlite3` folder.

We just talked about how to import packages that live in our workspace. To use our newly gotten `go-sqlite3` package, we'd import it like so:

```go
import (
  "github.com/mattn/go-sqlite3"
)
```

I know this looks like a URL but in reality, it'll simply import the `go-sqlite3` package which it expects to find in `$GOPATH/src/github.com/mattn/go-sqlite3`.

### Dependency Management

`go get` has a couple of other tricks up its sleeve. If we `go get` within a project, it'll scan all the files, looking for `imports` to third-party libraries and will download them. In a way, our own source code becomes a `Gemfile` or `package.json`.

If you call `go get -u` it'll update the packages (or you can update a specific package via `go get -u FULL_PACKAGE_NAME`).

Eventually, you might find `go get` inadequate. For one thing, there's no way to specify a revision, it always points to the master/head/trunk/default. This is an even larger problem if you have two projects needing different versions of the same library.

To solve this, you can use a third-party dependency management tool. They are still young, but two promising ones are [goop](https://github.com/nitrous-io/goop) and [godep](https://github.com/tools/godep). A more complete list is available at the [go-wiki](https://code.google.com/p/go-wiki/wiki/PackageManagementTools).

## Interfaces

Interfaces are types that define a contract but not an implementation. Here's an example:

```go
type Logger interface {
  Log(message string)
}
```

You might be wondering what purpose this could possibly serve. Interfaces help decouple your code from specific implementations. For example, we might have various types of loggers:

```go
type SqlLogger struct { ... }
type ConsoleLogger struct { ... }
type FileLogger struct { ... }
```

Yet by programming against the interface, rather than these concrete implementations, we can easily change (and test) which we use without any impact to our code.

How would you use one? Just like any other type, it could be a structure's field:

```go
type Server struct {
  logger Logger
}
```

or a function parameter (or return value):

```go
func process(logger Logger) {
  logger.Log("hello!")
}
```

In a language like C# or Java, we have to be explicit when a class implements an interface:

```go
public class ConsoleLogger : Logger {
  public void Logger(message string) {
    Console.WriteLine(message)
  }
}
```

In Go, this happens implicitly. If your structure has a function name `Log` with a `string` parameter and no return value, then it can be used as a `Logger`. This cuts down on the verboseness of using interfaces:

```go
type ConsoleLogger struct {}
func (l ConsoleLogger) Log(message string) {
  fmt.Println(message)
}
```

It also tends to promote small and focused interfaces. The standard library is full of interfaces. The `io` package has a handful of popular ones such as `io.Reader`, `io.Writer`, and `io.Closer`. If you write a function that expects a parameter that you'll only be calling `Close()` on, you absolutely should accept an `io.Closer` rather than whatever concrete type you're using.

Interfaces can also participate in composition. And, interfaces themselves can be composed of other interfaces. For example, `io.ReadCloser` is an interface composed of the `io.Reader` interface as well as the `io.Closer` interface.

Finally, interfaces are commonly used to avoid cyclical imports. Since they don't have implementations, they'll have limited dependencies.

## နောက်အခန်း မဖတ်ခင်

Ultimately, how you structure your code around Go's workspace is something that you'll only feel comfortable with after you've written a couple of non-trivial projects. What's most important for you to remember is the tight relationship between package names and your directory structure (not just within a project, but within the entire workspace).

The way Go handles visibility of types is straightforward and effective. It's also consistent. There are a few things we haven't looked at, such as constants and global variables but rest assured, their visibility is determined by the same naming rule.

Finally, if you're new to interfaces, it might take some time before you get a feel for them. However, the first time you see a function that expects something like `io.Reader`, you'll find yourself thanking the author for not demanding more than he or she needed.

# အခန်း (၅) - Tidbits

In this chapter, we'll talk about a miscellany of Go's feature which didn't quite fit anywhere else.

## Error Handling

Go's preferred way to deal with errors is through return values, not exceptions. Consider the `strconv.Atoi` function which takes a string and tries to convert it to an integer:

```go
package main

import (
  "fmt"
  "os"
  "strconv"
)

func main() {
  if len(os.Args) != 2 {
    os.Exit(1)
  }

  n, err := strconv.Atoi(os.Args[1])
  if err != nil {
    fmt.Println("not a valid number")
  } else {
    fmt.Println(n)
  }
}
```

You can create your own error type; the only requirement is that it fulfills the contract of the built-in `error` interface, which is:

```go
type error interface {
  Error() string
}
```

More commonly, we can create our own errors by importing the `errors` package and using it in the `New` function:

```go
import (
  "errors"
)


func process(count int) error {
  if count < 1 {
    return errors.New("Invalid count")
  }
  ...
  return nil
}
```

There's a common pattern in Go's standard library of using error variables. For example, the `io` package has an `EOF` variable which is defined as:

```go
var EOF = errors.New("EOF")
```

This is a package variable (it's defined outside of a function) which is publicly accessible (upper-case first letter). Various functions can return this error, say when we're reading from a file or STDIN. If it makes contextual sense, you should use this error, too. As consumers, we can use this singleton:

```go
package main

import (
  "fmt"
  "io"
)

func main() {
  var input int
  _, err := fmt.Scan(&input)
  if err == io.EOF {
    fmt.Println("no more input!")
  }
}
```

As a final note, Go does have `panic` and `recover` functions. `panic` is like throwing an exception while `recover` is like `catch`; they are rarely used.

## Defer

Even though Go has a garbage collector, some resources require that we explicitly release them. For example, we need to `Close()` files after we're done with them. This sort of code is always dangerous. For one thing, as we're writing a function, it's easy to forget to `Close` something that we declared 10 lines up. For another, a function might have multiple return points. Go's solution is the `defer` keyword:

```go
package main

import (
  "fmt"
  "os"
)

func main() {
  file, err := os.Open("a_file_to_read")
  if err != nil {
    fmt.Println(err)
    return
  }
  defer file.Close()
  // read the file
}
```

If you try to run the above code, you'll probably get an error (the file doesn't exist). The point is to show how `defer` works. Whatever you `defer` will be executed after the enclosing function (in this case `main()`) returns, even if it does so violently. This lets you release resources near where it’s initialized and takes care of multiple return points.

## go fmt

Most programs written in Go follow the same formatting rules, namely, a tab is used to indent and braces go on the same line as their statement.

I know, you have your own style and you want to stick to it. That's what I did for a long time, but I'm glad I eventually gave in. A big reason for this is the `go fmt` command. It's easy to use and authoritative (so no one argues over meaningless preferences).

When you're inside a project, you can apply the formatting rule to it and all sub-projects via:

```
go fmt ./...
```

Give it a try. It does more than indent your code; it also aligns field declarations and alphabetically orders imports.

## Initialized If

Go supports a slightly modified if-statement, one where a value can be initiated prior to the condition being evaluated:

```go
if x := 10; count > x {
  ...
}
```

That's a pretty silly example. More realistically, you might do something like:

```go
if err := process(); err != nil {
  return err
}
```

Interestingly, while the values aren't available outside the if-statement, they are available inside any `else if` or `else`.

## Empty Interface and Conversions

In most object-oriented languages, a built-in base class, often named `object`, is the superclass for all other classes. Go, having no inheritance, doesn't have such a superclass. What it does have is an empty interface with no methods: `interface{}`. Since every type implements all 0 of the empty interface's methods, and since interfaces are implicitly implemented, every type fulfills the contract of the empty interface.

 If we wanted to, we could write an `add` function with the following signature:

```go
func add(a interface{}, b interface{}) interface{} {
  ...
}
```

To convert an interface variable to an explicit type, you use `.(TYPE)`:

```go
return a.(int) + b.(int)
```

Note that if the underlying type is not `int`, the above will result in an error.

You also have access to a powerful type switch:

```go
switch a.(type) {
  case int:
    fmt.Printf("a is now an int and equals %d\n", a)
  case bool, string:
    // ...
  default:
    // ...
}
```

You'll see and probably use the empty interface more than you might first expect. Admittedly, it won't result in clean code. Converting values back and forth is ugly and dangerous but sometimes, in a static language, it's the only choice.

## Strings and Byte Arrays

Strings and byte arrays are closely related. We can easily convert one to the other:

```go
stra := "the spice must flow"
byts := []byte(stra)
strb := string(byts)
```

In fact, this way of converting is common across various types as well. Some functions explicitly expect an `int32` or an `int64` or their unsigned counterparts. You might find yourself having to do things like:

```go
int64(count)
```

Still, when it comes to bytes and strings, it's probably something you'll end up doing often. Do note that when you use `[]byte(X)` or `string(X)`, you're creating a copy of the data. This is necessary because strings are immutable.

Strings are made of `runes` which are unicode code points. If you take the length of a string, you might not get what you expect. The following prints 3:

    fmt.Println(len("椒"))

If you iterate over a string using `range`, you'll get runes, not bytes. Of course, when you turn a string into a `[]byte` you'll get the correct data.

## Function Type

Functions are first-class types:

```go
type Add func(a int, b int) int
```

which can then be used anywhere -- as a field type, as a parameter, as a return value.

```go
package main

import (
  "fmt"
)

type Add func(a int, b int) int

func main() {
  fmt.Println(process(func(a int, b int) int{
      return a + b
  }))
}

func process(adder Add) int {
  return adder(1, 2)
}
```

Using functions like this can help decouple code from specific implementations much like we achieve with interfaces.

## နောက်အခန်း မဖတ်ခင်

We looked at various aspects of programming with Go. Most notably, we saw how error handling behaves and how to release resources such as connections and open files. Many people dislike Go's approach to error handling. It can feel like a step backwards. Sometimes, I agree. Yet, I also find that it results in code that's easier to follow. `defer` is an unusual but practical approach to resource management. In fact, it isn't tied to resource management only. You can use `defer` for any purpose, such as logging when a function exits.

Certainly, we haven't looked at all of the tidbits Go has to offer. But you should be feeling comfortable enough to tackle whatever you come across.

# Chapter 6 - Concurrency

Go is often described as a concurrent-friendly language. The reason for this is that it provides a simple syntax over two powerful mechanisms: goroutines and channels.

## Goroutines

A goroutine is similar to a thread, but it is scheduled by Go, not the OS. Code that runs in a goroutine can run concurrently with other code. Let's look at an example:

```go
package main

import (
  "fmt"
  "time"
)

func main() {
  fmt.Println("start")
  go process()
  time.Sleep(time.Millisecond * 10) // this is bad, don't do this!
  fmt.Println("done")
}

func process() {
  fmt.Println("processing")
}
```

There are a few interesting things going on here, but the most important is how we start a goroutine. We simply use the `go` keyword followed by the function we want to execute. If we just want to run a bit of code, such as the above, we can use an anonymous function. Do note that anonymous functions aren't only used with goroutines, however.

```go
go func() {
  fmt.Println("processing")
}()
```

Goroutines are easy to create and have little overhead. Multiple goroutines will end up running on the same underlying OS thread. This is often called an M:N threading model because we have M application threads (goroutines) running on N OS threads. The result is that a goroutine has a fraction of overhead (a few KB) than OS threads. On modern hardware, it's possible to have millions of goroutines.

Furthermore, the complexity of mapping and scheduling is hidden. We just say *this code should run concurrently* and let Go worry about making it happen.

If we go back to our example, you'll notice that we had to `Sleep` for a few milliseconds. That's because the main process exits before the goroutine gets a chance to execute (the process doesn't wait until all goroutines are finished before exiting). To solve this, we need to coordinate our code.

## Synchronization

Creating goroutines is trivial, and they are so cheap that we can start many; however, concurrent code needs to be coordinated. To help with this problem, Go provides `channels`. Before we look at `channels`, I think it's important to understand a little bit about the basics of concurrent programming.

Writing concurrent code requires that you pay specific attention to where and how you read and write values. In some ways, it's like programming without a garbage collector -- it requires that you think about your data from a new angle, always watchful for possible danger. Consider:

```go
package main

import (
  "fmt"
  "time"
)

var counter = 0

func main() {
  for i := 0; i < 20; i++ {
    go incr()
  }
  time.Sleep(time.Millisecond * 10)
}

func incr() {
  counter++
  fmt.Println(counter)
}
```

What do you think the output will be?

If you think the output is `1, 2, ... 20` you're both right and wrong. It's true that if you run the above code, you'll sometimes get that output. However, the reality is that the behavior is undefined. Why? Because we potentially have multiple (two in this case) goroutines writing to the same variable, `counter`, at the same time. Or, just as bad, one goroutine would be reading `counter` while another writes to it.

Is that really a danger? Yes, absolutely. `counter++` might seem like a simple line of code, but it actually gets broken down into multiple assembly statements -- the exact nature is dependent on the platform that you're running. If you run this example, you'll see that very often the numbers are printed in a weird order, and/or numbers are duplicated/missing. There are worse possibilities too, such as system crashes or accessing an arbitrary piece of data and incrementing it!

The only concurrent thing you can safely do to a variable is to read from it. You can have as many readers as you want, but writes need to be synchronized. There are various ways to do this, including using some truly atomic operations that rely on special CPU instructions. However, the most common approach is to use a mutex:

```go
package main

import (
  "fmt"
  "time"
  "sync"
)

var (
  counter = 0
  lock sync.Mutex
)

func main() {
  for i := 0; i < 20; i++ {
    go incr()
  }
  time.Sleep(time.Millisecond * 10)
}

func incr() {
  lock.Lock()
  defer lock.Unlock()
  counter++
  fmt.Println(counter)
}
```

A mutex serializes access to the code under lock. The reason we simply define our lock as `lock sync.Mutex` is because the default value of a `sync.Mutex` is unlocked.

Seems simple enough? The example above is deceptive. There's a whole class of serious bugs that can arise when doing concurrent programming. First of all, it isn't always so obvious what code needs to be protected. While it might be tempting to use coarse locks (locks that cover a large amount of code), that undermines the very reason we're doing concurrent programming in the first place. We generally want fine locks; else, we end up with a ten-lane highway that suddenly turns into a one-lane road.

The other problem has to do with deadlocks. With a single lock, this isn't a problem, but if you're using two or more locks around the same code, it's dangerously easy to have situations where goroutineA holds lockA but needs access to lockB, while goroutineB holds lockB but needs access to lockA.

It actually *is* possible to deadlock with a single lock, if we forget to release it. This isn't as dangerous as a multi-lock deadlock (because those are *really* tough to spot), but just so you can see what happens, try running:

```go
package main

import (
  "time"
  "sync"
)

var (
  lock sync.Mutex
)

func main() {
  go func() { lock.Lock() }()
  time.Sleep(time.Millisecond * 10)
  lock.Lock()
}
```

There's more to concurrent programming than what we've seen so far. For one thing, there's another common mutex called a read-write mutex. This exposes two locking functions: one to lock for reading and one to lock for writing. This distinction allows multiple simultaneous readers while ensuring that writing is exclusive. In Go, `sync.RWMutex` is such a lock. In addition to the `Lock` and `Unlock` methods of a `sync.Mutex`, it also exposes `RLock` and `RUnlock` methods; where `R` stands for *Read*. While read-write mutexes are commonly used, they place an additional burden on developers: we must now pay attention to not only when we're accessing data, but also how.

Furthermore, part of concurrent programming isn't so much about serializing access across the narrowest possible piece of code; it's also about coordinating multiple goroutines. For example, sleeping for 10 milliseconds isn't a particularly elegant solution. What if a goroutine takes more than 10 milliseconds? What if it takes less and we're just wasting cycles? Also, what if instead of just waiting for goroutines to finish, we want to tell one *hey, I have new data for you to process!*?

These are all things that are doable without `channels`. Certainly for simpler cases, I believe you **should** use primitives such as `sync.Mutex` and `sync.RWMutex`, but as we'll see in the next section, `channels` aim at making concurrent programming cleaner and less error-prone.

## Channels

The challenge with concurrent programming stems from sharing data. If your goroutines share no data, you needn't worry about synchronizing them. That isn't an option for all systems, however. In fact, many systems are built with the exact opposite goal in mind: to share data across multiple requests. An in-memory cache or a database, are good examples of this. This is becoming an increasingly common reality.

Channels help make concurrent programming saner by taking shared data out of the picture. A channel is a communication pipe between goroutines which is used to pass data. In other words, a goroutine that has data can pass it to another goroutine via a channel. The result is that, at any point in time, only one goroutine has access to the data.

A channel, like everything else, has a type. This is the type of data that we'll be passing through our channel. For example, to create a channel which can be used to pass an integer around, we'd do:

```go
c := make(chan int)
```

The type of this channel is `chan int`. Therefore, to pass this channel to a function, our signature looks like:

```go
func worker(c chan int) { ... }
```

Channels support two operations: receiving and sending. We send to a channel by doing:

```
CHANNEL <- DATA
```

and receive from one by doing

```
VAR := <-CHANNEL
```

The arrow points in the direction that data flows. When sending, the data flows into the channel. When receiving, the data flows out of the channel.

The final thing to know before we look at our first example is that receiving and sending to and from a channel is blocking. That is, when we receive from a channel, execution of the goroutine won't continue until data is available. Similarly, when we send to a channel, execution won't continue until the data is received.

Consider a system with incoming data that we want to handle in separate goroutines. This is a common requirement. If we did our data-intensive processing on the goroutine which accepts the incoming data, we'd risk timing out clients. First, we'll write our worker. This could be a simple function, but I'll make it part of a structure since we haven't seen goroutines used like this before:

```go
type Worker struct {
  id int
}

func (w Worker) process(c chan int) {
  for {
    data := <-c
    fmt.Printf("worker %d got %d\n", w.id, data)
  }
}
```

Our worker is simple. It waits until data is available then "processes" it. Dutifully, it does this in a loop, forever waiting for more data to process.

To use this, the first thing we'd do is start some workers:

```go
c := make(chan int)
for i := 0; i < 5; i++ {
  worker := &Worker{id: i}
  go worker.process(c)
}
```

And then we can give them some work:

```go
for {
  c <- rand.Int()
  time.Sleep(time.Millisecond * 50)
}
```

Here's the complete code to make it run:

```go
package main

import (
  "fmt"
  "time"
  "math/rand"
)

func main() {
  c := make(chan int)
  for i := 0; i < 5; i++ {
    worker := &Worker{id: i}
    go worker.process(c)
  }

  for {
    c <- rand.Int()
    time.Sleep(time.Millisecond * 50)
  }
}

type Worker struct {
  id int
}

func (w *Worker) process(c chan int) {
  for {
    data := <-c
    fmt.Printf("worker %d got %d\n", w.id, data)
  }
}
```

We don't know which worker is going to get what data. What we do know, what Go guarantees, is that the data we send to a channel will only be received by a single receiver.

Notice that the only shared state is the channel, which we can safely receive from and send to concurrently. Channels provide all of the synchronization code we need and also ensure that, at any given time, only one goroutine has access to a specific piece of data.

### Buffered Channels

Given the above code, what happens if we have more data coming in than we can handle? You can simulate this by changing the worker to sleep after it has received data:

```go
for {
  data := <-c
  fmt.Printf("worker %d got %d\n", w.id, data)
  time.Sleep(time.Millisecond * 500)
}
```

What's happening is that our main code, the one that accepts the user's incoming data (which we just simulated with a random number generator) is blocking as it sends to the channel because no receiver is available.

In cases where you need high guarantees that the data is being processed, you probably will want to start blocking the client. In other cases, you might be willing to loosen those guarantees. There are a few popular strategies to do this. The first is to buffer the data. If no worker is available, we want to temporarily store the data in some sort of queue. Channels have this buffering capability built-in. When we created our channel with `make`, we can give our channel a length:

```go
c := make(chan int, 100)
```

You can make this change, but you'll notice that the processing is still choppy. Buffered channels don't add more capacity; they merely provide a queue for pending work and a good way to deal with a sudden spike. In our example, we're continuously pushing more data than our workers can handle.

Nevertheless, we can get a sense what the buffered channel is, in fact, buffering by looking at the channel's `len`:

```go
for {
  c <- rand.Int()
  fmt.Println(len(c))
  time.Sleep(time.Millisecond * 50)
}
```

You can see that it grows and grows until it fills up, at which point sending to our channel start to block again.

### Select

Even with buffering, there comes a point where we need to start dropping messages. We can't use up an infinite amount of memory hoping a worker frees up. For this, we use Go's `select`.

Syntactically, `select` looks a bit like a switch. With it, we can provide code for when the channel isn't available to send to. First, let's remove our channel's buffering so that we can clearly see how `select` works:

```go
c := make(chan int)
```

Next, we change our `for` loop:

```go
for {
  select {
  case c <- rand.Int():
    //optional code here
  default:
    //this can be left empty to silently drop the data
    fmt.Println("dropped")
  }
  time.Sleep(time.Millisecond * 50)
}
```

We're pushing out 20 messages per second, but our workers can only handle 10 per second; thus, half the messages get dropped.

This is only the start of what we can accomplish with `select`. A main purpose of select is to manage multiple channels. Given multiple channels, `select` will block until the first one becomes available. If no channel is available, `default` is executed if one is provided. A channel is randomly picked when multiple are available.

It's hard to come up with a simple example that demonstrates this behavior as it's a fairly advanced feature. The next section might help illustrate this though.

### Timeout

We've looked at buffering messages as well as simply dropping them. Another popular option is to timeout. We're willing to block for some time, but not forever. This is also something easy to achieve in Go. Admittedly, the syntax might be hard to follow but it's such a neat and useful feature that I couldn't leave it out.

To block for a maximum amount of time, we can use the `time.After` function. Let's look at it then try to peek beyond the magic. To use this, our sender becomes:

```go
for {
  select {
  case c <- rand.Int():
  case <-time.After(time.Millisecond * 100):
    fmt.Println("timed out")
  }
  time.Sleep(time.Millisecond * 50)
}
```

`time.After` returns a channel, so we can `select` from it. The channel is written to after the specified time expires. That's it. There's nothing more magical than that. If you're curious, here's what an implementation of `after` could look like:

```go
func after(d time.Duration) chan bool {
  c := make(chan bool)
  go func() {
    time.Sleep(d)
    c <- true
  }()
  return c
}
```

Back to our `select`, there are a couple of things to play with. First, what happens if you add the `default` case back? Can you guess? Try it. If you aren't sure what's going on, remember that `default` fires immediately if no channel is available.

Also, `time.After` is a channel of type `chan time.Time`. In the above example, we simply discard the value that was sent to the channel. If you want though, you can receive it:

```go
case t := <-time.After(time.Millisecond * 100):
  fmt.Println("timed out at", t)
```

Pay close attention to our `select`. Notice that we're sending to `c` but receiving from `time.After`. `select` works the same regardless of whether we're receiving from, sending to, or any combination of channels:

* The first available channel is chosen.
* If multiple channels are available, one is randomly picked.
* If no channel is available, the default case is executed.
* If there's no default, select blocks.

Finally, it's common to see a `select` inside a `for`. Consider:

```go
for {
  select {
  case data := <-c:
    fmt.Printf("worker %d got %d\n", w.id, data)
  case <-time.After(time.Millisecond * 10):
    fmt.Println("Break time")
    time.Sleep(time.Second)
  }
}
```

## နောက်အခန်း မဖတ်ခင်

If you're new to the world of concurrent programming, it might all seem rather overwhelming. It categorically demands considerably more attention and care. Go aims to make it easier.

Goroutines effectively abstract what's needed to run concurrent code. Channels help eliminate some serious bugs that can happen when data is shared by eliminating the sharing of data. This doesn't just eliminate bugs, but it changes how one approaches concurrent programming. You start to think about concurrency with respect to message passing, rather than dangerous areas of code.

Having said that, I still make extensive use of the various synchronization primitives found in the `sync` and `sync/atomic` packages. I think it's important to be comfortable with both. I encourage you to first focus on channels, but when you see a simple example that needs a short-lived lock, consider using a mutex or read-write mutex.

# နိဒါန်း

I recently heard Go described as a *boring* language. Boring because it's easy to learn, easy to write and, most importantly, easy to read. Perhaps, I did this reality a disservice. We *did* spend three chapters talking about types and how to declare variables after all.

If you have a background in a statically typed language, much of what we saw was probably, at best, a refresher. That Go makes pointers visible and that slices are thin wrappers around arrays probably isn't overwhelming to seasoned Java or C# developers.

If you've mostly been making use of dynamic languages, you might feel a little different. It *is* a fair bit to learn. Not least of which is the various syntax around declaration and initialization. Despite being a fan of Go, I find that for all the progress towards simplicity, there's something less than simple about it. Still, it comes down to some basic rules (like you can only declare variable once and `:=` does declare the variable) and fundamental understanding (like `new(X)` or `&X{}` only allocate memory, but slices, maps and channels require more initialization and thus, `make`).

Beyond this, Go gives us a simple but effective way to organize our code. Interfaces, return-based error handling, `defer` for resource management and a simple way to achieve composition.

Last but not least is the built-in support for concurrency. There's little to say about goroutines other than they’re effective and simple (simple to use anyway). It's a good abstraction. Channels are more complicated. I always think it's important to understand basics before using high-level wrappers. I *do* think learning about concurrent programming without channels is useful. Still, channels are implemented in a way that, to me, doesn't feel quite like a simple abstraction. They are almost their own fundamental building block. I say this because they change how you write and think about concurrent programming. Given how hard concurrent programming can be, that is definitely a good thing.
